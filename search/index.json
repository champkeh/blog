{"results":[{"href":"https://blog.champ.design/posts/2021/10/adding-search-to-site/","title":"给 hugo 站点添加搜索功能","body":"前言 ¶ 对于数据库驱动的网站，我们可以执行SQL查询关键字进行搜索；而对于静态站点，我们需要首先生成索引文件，然后用一个搜索引擎进行查询。\n这里我们使用一个纯前端的搜索引擎 Lunr 生成文章列表数据 ¶ 因为我们的网站是用 hugo 搭建的静态网站，所以我们要在 hugo 构建时生成 json 格式的文章列表。\n创建json模板 创建模板文件layout/_default/search.json，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12  {\u0026#34;results\u0026#34;: [{{- range $index, $page := .Site.RegularPages }}{{- if $index -}}, {{- end }}{\u0026#34;href\u0026#34;: {{$page.Permalink | jsonify }},\u0026#34;title\u0026#34;: {{$page.Title | jsonify }},\u0026#34;body\u0026#34;: {{$page.Content | plainify | jsonify }}}{{- end }}]}  应用数据模板生成文章列表数据 默认情况下，我们只有数据模板是不会自动生成数据的，我们需要显式使用这个模板。\n首先，创建一个 search.md 文档：\n1  hugo new search.md   我们不需要这个文档的内容，我们只是使用它的front matter来指定输出格式，如下所示：\n1 2 3 4  ---layout:searchoutputs:[\u0026#34;JSON\u0026#34;]---  我们指定了这个文档的模板采用我们之前创建的数据模板文件search，输出格式指定为JSON。 这样在 hugo 构建时就会输出一个search/index.json文件，内容就是我们网站的所有文章生成的一个 json 文件。\n构建索引文件 ¶ 在主页使用axios获取文章列表：\n1 2 3  axios.get(\u0026#34;/search/index.json\u0026#34;).then(response =\u0026gt; { window.ArticleList = response.data.result })   构建lunr的索引文件：\n1 2 3 4 5 6 7 8  const LunrSearchIndex = lunr(function () { this.ref(\u0026#39;href\u0026#39;) this.field(\u0026#39;title\u0026#39;) this.field(\u0026#39;body\u0026#39;) window.ArticleList.forEach(article =\u0026gt; { this.add(article) }) })   执行搜索 ¶ 这一部分就比较简单了，我们有了文章的索引直接调用search就可以了：\n1 2  let searchText = \u0026#39;search text from input\u0026#39; let resultList = LunrSearchIndex.search(searchText)   关于lunr支持的搜索语法，可以查看Lurn#Search "},{"href":"https://blog.champ.design/posts/2021/10/position-sticky-not-working/","title":"Sticky 定位无效的一些坑","body":"场景 ¶ 在开发这个网站时，我想让顶部的导航栏/搜索栏在滚动时固定在屏幕顶部，这样会更方便用户的操作。期望的效果如下：\n初步实现的代码 (无效代码😟) ¶ HTML 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;wrapper\u0026#34;\u0026gt;需要定位的元素\u0026lt;/div\u0026gt;  \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt;   CSS 1 2 3 4 5 6 7 8 9 10 11 12 13 14  .header { padding-top: 200px; } .wrapper { height: 100px; background-color: red; position: sticky; top: 0; } .box { height: 200px; background-color: #6a737d; margin: 20px 0; }   正如高亮部分的代码那样，我设置了.wrapper元素的sticky相关属性后并没有什么效果。\n求助 Google 😊 ¶ 搜了一圈，网上关于sticky无效的几个原因大概如下：\n 必须指定top/bottom/left/right这几个属性之一 父容器的高度要大于sticky元素的高度 任意父节点的overflow属性必须都是visible  在我们这个例子里，要定位的元素是.wrapper，父容器是.header。我们没有给.header显式设置高度，因此它的高度是由内容撑开的，也就是说，父容器 .header的高度等于子元素.wrapper的高度，不满足第2点，因此sticky定位无效。\n但是这里我们又不能通过设置.header的高度来实现，而是要基于.container作为容器来设置sticky，要不然就会出现下面这种奇怪的行为：\n.wrapper元素虽然会吸顶，但是当滚动距离大于.header的高度后，会被后面的元素顶上去，也不是我们想要的。\n变通办法 ¶ 暂时没有找到比较好的解决方法，我们只能把.header元素设置为sticky定位，然后调整top值来达到我们想要的效果。\n相关代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  .header { padding-top: 200px; position: sticky; top: -200px; } .wrapper { height: 100px; background-color: red; } .box { height: 200px; background-color: #6a737d; margin: 20px 0; }   总结 ¶ 要想实现元素吸顶效果，必须设置滚动容器内的直接子元素为sticky定位，不能是后代子元素。\n参考 ¶  https://www.designcise.com/web/tutorial/how-to-fix-issues-with-css-position-sticky-not-working#checking-if-a-parent-element-is-a-flexbox   "},{"href":"https://blog.champ.design/posts/2021/goal/","title":"2021年目标","body":"2021年要达到的目标如下：\n 把blog和tools这两个项目搭建起来，配置自动发布，后续来了兴致也不至于没有地方写代码。 阅读《深入理解计算机系统》这本书 阅读并学习ECMAScript规范  "},{"href":"https://blog.champ.design/posts/2021/10/blog-build-process/","title":"网站搭建过程","body":"框架选型 ¶ 这个网站为纯静态站点，不涉及数据库及用户的信息存储，所以采用静态站点生成器来实现。而目前我正在学习golang语言，所以也就顺理成章地选择了hugo。\n1  $ hugo new site champ.design   关于主题 ¶ 网站最开始采用的 jane 主题，看起来是下面这样子：\n不过一直都感觉不太符合我的审美。 直到有一天，我看到了这个网站 的设计，给了我一种特别的感觉。或许这就是我想要的效果吧，简洁而又大方，没有那么花里胡哨：\n因此，这个网站的主题从此就基于它进行二次开发了。\n1  $ hugo new theme basic   关于自动发布 ¶ 采用 Github Actions 的自动发布机制。\n 关于采用Github Actions自动发布hugo站点，可以参考 这篇文章 和 这篇文章  在项目根目录下添加.github/workflows/deploy.yml文件(文件名随意，但必须放在.github/workflows目录下面)，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  # Workflow to build and deploy site to Github Pages using Hugoname:Build and Deploy Blog siteon:push:branches:[master ]jobs:build-and-deploy:runs-on:ubuntu-lateststeps:# Step 1 - Checks-out your repository under $GITHUB_WORKSPACE- name:Checkout 🛎️uses:actions/checkout@v2# Step 2 - Sets up the latest version of Hugo- name:Setup Hugo 🔧uses:peaceiris/actions-hugo@v2with:hugo-version:\u0026#39;latest\u0026#39;extended:true# Step 3 - Install Dependencies and Build site- name:Install and Build 🔧run:|yarn yarn build# Step 4 - Create name file- name:Create cname filerun:echo \u0026#39;blog.champ.design\u0026#39; \u0026gt; public/CNAME# Step 5 - Push our generated site to our gh-pages branch- name:Deployuses:JamesIves/github-pages-deploy-action@3.7.1with:ACCESS_TOKEN:${{ secrets.GITHUB_TOKEN }}BRANCH:gh-pagesFOLDER:publicCLEAN:true  后续对网站的完善 ¶  优化页面样式及交互 集成现代前端开发工具链 集成 tools 项目，tools项目采用sveltejs开发 开发实验室功能，功能待定  "},{"href":"https://blog.champ.design/posts/2019/05/deno_install_explain/","title":"Deno安装脚本的解读","body":"install.sh源码 deno的完整安装脚本如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  #!/bin/sh  # 当命令的返回值为非零状态时，则立即退出脚本的执行 set -e # 定义变量os case $(uname -s) in Darwin) os=\u0026#34;osx\u0026#34; ;; *) os=\u0026#34;linux\u0026#34; ;; esac # 定义变量arch case $(uname -m) in x86_64) arch=\u0026#34;x86_64\u0026#34; ;; *) arch=\u0026#34;other\u0026#34; ;; esac # 如果上面得到的 arch 变量不是 x86_64，则退出安装 if [ \u0026#34;$arch\u0026#34; = \u0026#34;other\u0026#34; ]; then echo \u0026#34;Unsupported architecture $(uname -m). Only x64 binaries are available.\u0026#34; exit fi # $# 的意思是，传递给该脚本的参数个数 # 可以通过 $1 $2 ... 按照位置拿到这些参数 # 下面这块代码的目的，是拿到要下载的安装包地址 if [$# -eq 0 ]; then # 按照readme的安装说明，无参代表安装最新版 # 注意下面管道符的使用，用来流式处理命令的结果 deno_asset_path=$(curl -sSf https://github.com/denoland/deno/releases | grep -o \u0026#34;/denoland/deno/releases/download/.*/deno_${os}_x64\\\\.gz\u0026#34; | head -n 1) if [ ! \u0026#34;$deno_asset_path\u0026#34; ]; then exit 1; fi deno_uri=\u0026#34;https://github.com${deno_asset_path}\u0026#34; else # 安装指定版本，版本号通过参数 $1 获取 deno_uri=\u0026#34;https://github.com/denoland/deno/releases/download/${1}/deno_${os}_x64.gz\u0026#34; fi # 定义deno二进制文件的安装路径和可执行文件路径 # 根据 issue#40,这个路径在将来可能会发生变化 # https://github.com/denoland/deno_install/issues/40 bin_dir=\u0026#34;$HOME/.deno/bin\u0026#34; exe=\u0026#34;$bin_dir/deno\u0026#34; # 如果目录还不存在，则创建 if [ ! -d \u0026#34;$bin_dir\u0026#34; ]; then mkdir -p \u0026#34;$bin_dir\u0026#34; fi # 下载安装包 # curl 的 -o 选项表示写入上面定义的文件路径中 # curl 的 -# 选项表示显示进度 curl -fL# -o \u0026#34;$exe.gz\u0026#34; \u0026#34;$deno_uri\u0026#34; # 下载完二进制文件之后，进行解压 gunzip -df \u0026#34;$exe.gz\u0026#34; # 添加执行权限 chmod +x \u0026#34;$exe\u0026#34; echo \u0026#34;Deno was installed successfully to $exe\u0026#34; # 测试 deno 是否在 PATH 中定义 if command -v deno \u0026gt;/dev/null; then echo \u0026#34;Run \u0026#39;deno --help\u0026#39; to get started\u0026#34; else echo \u0026#34;Manually add the directory to your \\$HOME/.bash_profile (or similar)\u0026#34; echo \u0026#34; export PATH=\\\u0026#34;$bin_dir:\\$PATH\\\u0026#34;\u0026#34; echo \u0026#34;Run \u0026#39;$exe--help\u0026#39; to get started\u0026#34; fi   关于set -e的作用，参考shell脚本中set -e选项作用范围 关于command命令的解释，参考shell command命令  注意: 关于curl命令的-L选项 1 2 3 4  $ curl -h ... -L, --location Follow redirects ...    该选项可以跟随url的重定向，所以对于github上的资源下载是很重要的我自己在调试的时候，为了简单，没有使用该选项，所以导致下载了错误的文件 "},{"href":"https://blog.champ.design/posts/2019/05/mongo-learn-note-1/","title":"MongoDB 学习笔记之CRUD","body":"启动一个 MongoDB 服务器容器 ¶ 1 2  $ docker pull mongo:4 $ docker run --name mymongo -v /data/docker-db:/data/db -d mongo:4   启动 Mongo Express 容器 ¶ 1 2  $ docker pull mongo-express $ docker run --link mymongo:mongo -p 8081:8081 -d mongo-express   在浏览器打开 http://localhost:8081，mongo-expres 的界面如下:\n启动 Mongo shell ¶ 1  $ docker exec -it mymongo mongo   文档的基本操作 ¶ 1 2 3 4 5 6 7 8 9 10 11 12  # 查看所有数据库 \u0026gt; show dbs admin 0.000GB config 0.000GB local 0.000GB # 切换到 test 数据库 \u0026gt; use test switched to db test # 查看 test 数据库中的集合 \u0026gt; show collections   创建文档 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159  # 准备写入数据库的文档 # { # _id: \u0026#34;account1\u0026#34;, # name: \u0026#34;alice\u0026#34;, # balance: 100 # } # 将文档写入 accounts 集合 \u0026gt; db.accounts.insertOne( ... { ... _id: \u0026#34;account1\u0026#34;, ... name: \u0026#34;alice\u0026#34;, ... balance: 100 ... } ...) { \u0026#34;acknowledged\u0026#34;: true, \u0026#34;insertedId\u0026#34;: \u0026#34;account1\u0026#34; } # 写入id重复的数据时 \u0026gt; db.accounts.insertOne( ... { ... _id: \u0026#34;account1\u0026#34;, ... name: \u0026#34;bob\u0026#34;, ... balance: 200 ... } ...) 2019-05-18T13:37:29.722+0000 E QUERY [js] WriteError: E11000 duplicate key error collection: test.accounts index: _id_ dup key: { : \u0026#34;account1\u0026#34; } : WriteError({ \u0026#34;index\u0026#34; : 0, \u0026#34;code\u0026#34; : 11000, \u0026#34;errmsg\u0026#34; : \u0026#34;E11000 duplicate key error collection: test.accounts index: _id_ dup key: { : \\\u0026#34;account1\\\u0026#34; }\u0026#34;, \u0026#34;op\u0026#34; : { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;bob\u0026#34;, \u0026#34;balance\u0026#34; : 200 } }) WriteError@src/mongo/shell/bulk_api.js:461:48 Bulk/mergeBatchResults@src/mongo/shell/bulk_api.js:841:49 Bulk/executeBatch@src/mongo/shell/bulk_api.js:906:13 Bulk/this.execute@src/mongo/shell/bulk_api.js:1150:21 DBCollection.prototype.insertOne@src/mongo/shell/crud_api.js:252:9 @(shell):1:1 # 使用 try-catch 捕获错误 \u0026gt; try { ... db.accounts.insertOne( ... { ... _id: \u0026#34;account1\u0026#34;, ... name: \u0026#34;bob\u0026#34;, ... balance: 200 ... } ... ) ...} catch (e) { ... print(e) ...} WriteError({ \u0026#34;index\u0026#34; : 0, \u0026#34;code\u0026#34; : 11000, \u0026#34;errmsg\u0026#34; : \u0026#34;E11000 duplicate key error collection: test.accounts index: _id_ dup key: { : \\\u0026#34;account1\\\u0026#34; }\u0026#34;, \u0026#34;op\u0026#34; : { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;bob\u0026#34;, \u0026#34;balance\u0026#34; : 200 } }) # 创建多个文档 \u0026gt; db.accounts.insertMany( [ ... { ... name: \u0026#39;charlie\u0026#39;, ... balance: 500 ... }, ... { ... name: \u0026#39;david\u0026#39;, ... balance: 200 ... } ... ] ) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;insertedIds\u0026#34; : [ ObjectId(\u0026#34;5ce00d5972e77e7cb392a8fe\u0026#34;), ObjectId(\u0026#34;5ce00d5972e77e7cb392a8ff\u0026#34;) ] } # 顺序写出现错误时 \u0026gt; try { ... db.accounts.insertMany( [ ... { ... _id: \u0026#39;account1\u0026#39;, ... name: \u0026#39;edwrad\u0026#39;, ... balance: 700 ... }, ... { ... name: \u0026#39;fred\u0026#39;, ... balance: 20 ... } ... ] ) ... } catch(e) { ... print(e) ... } BulkWriteError({ \u0026#34;writeErrors\u0026#34; : [ { \u0026#34;index\u0026#34; : 0, \u0026#34;code\u0026#34; : 11000, \u0026#34;errmsg\u0026#34; : \u0026#34;E11000 duplicate key error collection: test.accounts index: _id_ dup key: { : \\\u0026#34;account1\\\u0026#34; }\u0026#34;, \u0026#34;op\u0026#34; : { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;edwrad\u0026#34;, \u0026#34;balance\u0026#34; : 700 } } ], \u0026#34;writeConcernErrors\u0026#34; : [ ], \u0026#34;nInserted\u0026#34; : 0, #注意这里，插入条数为0 \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nMatched\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 0, \u0026#34;nRemoved\u0026#34; : 0, \u0026#34;upserted\u0026#34; : [ ] }) # 乱序写出现错误时 \u0026gt; try { ... db.accounts.insertMany( [ ... { ... _id: \u0026#39;account1\u0026#39;, ... name: \u0026#39;edwrad\u0026#39;, ... balance: 700 ... }, ... { ... name: \u0026#39;fred\u0026#39;, ... balance: 20 ... } ... ], { ordered: false } ) ... } catch(e) { ... print(e) ... } BulkWriteError({ \u0026#34;writeErrors\u0026#34; : [ { \u0026#34;index\u0026#34; : 0, \u0026#34;code\u0026#34; : 11000, \u0026#34;errmsg\u0026#34; : \u0026#34;E11000 duplicate key error collection: test.accounts index: _id_ dup key: { : \\\u0026#34;account1\\\u0026#34; }\u0026#34;, \u0026#34;op\u0026#34; : { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;edwrad\u0026#34;, \u0026#34;balance\u0026#34; : 700 } } ], \u0026#34;writeConcernErrors\u0026#34; : [ ], \u0026#34;nInserted\u0026#34; : 1, #成功插入了1条 \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nMatched\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 0, \u0026#34;nRemoved\u0026#34; : 0, \u0026#34;upserted\u0026#34; : [ ] })    总结db.collection.insertMany() 处理错误的方式: 1 2 3 4 5 6 7 8 9  { _id: \u0026#34;account1\u0026#34;, name: \u0026#34;edwrad\u0026#34;, -------\u0026gt; 错误的文档 balance: 700 } { name: \u0026#34;fred\u0026#34;, -------\u0026gt; 正确的文档 balance: 20 }    在顺序写入时，一旦遇到错误，操作便会退出，剩余的文档无论正确与否，都不会被写入所以，上面这两个文档都不会被写入到数据库在乱序写入时，即使某些文档造成了错误，剩余的正确的文档仍然会被写入 所以，第二篇文档会被正常写入数据库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  # insert 命令 # 创建单个或多个文档 \u0026gt; db.accounts.insert( ... { ... name: \u0026#39;george\u0026#39;, ... balance: 1000 ... } ... ) WriteResult({ \u0026#34;nInserted\u0026#34; : 1 }) \u0026gt; db.accounts.insert( [ ... { ... name: \u0026#39;abc\u0026#39;, ... balance: 200 ... }, ... { ... name: \u0026#39;xyz\u0026#39;, ... balance: 200 ... } ] ) BulkWriteResult({ \u0026#34;writeErrors\u0026#34;: [ ], \u0026#34;writeConcernErrors\u0026#34;: [ ], \u0026#34;nInserted\u0026#34;: 2, \u0026#34;nUpserted\u0026#34;: 0, \u0026#34;nMatched\u0026#34;: 0, \u0026#34;nModified\u0026#34;: 0, \u0026#34;nRemoved\u0026#34;: 0, \u0026#34;upserted\u0026#34;: [ ] })   1 2 3 4 5 6 7 8 9 10 11  # save 创建单一文档 \u0026gt; db.accounts.save( { name: \u0026#39;\u0026#39;, balance: 200 }, { writeConcern: \u0026lt;document\u0026gt; } ) # save 会调用 insert 创建文档，所以 save 的返回类型和 insert 相同   对象主键 默认的对象主键 objectId\n1 2 3 4 5 6 7  # 生成objectId主键 \u0026gt; ObjectId() ObjectId(\u0026#34;5ce0ec0672e77e7cb392a90b\u0026#34;) # 提前 ObjectId 的创建时间 \u0026gt; ObjectId(\u0026#34;5ce0ec0672e77e7cb392a90b\u0026#34;).getTimestamp() ISODate(\u0026#34;2019-05-19T05:39:18Z\u0026#34;)   复合主键 可以使用文档作为文档的主键\n1 2 3 4 5 6 7  \u0026gt; db.accounts.insert( { _id: { accountNo: \u0026#34;001\u0026#34;, type: \u0026#34;savings\u0026#34; }, name: \u0026#34;irene\u0026#34;, balance: 80 } )   读取文档 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76  # find 支持匹配查询和投射 db.\u0026lt;collection\u0026gt;.find(\u0026lt;query\u0026gt;, \u0026lt;projection\u0026gt;) \u0026lt;query\u0026gt;定义了搜索条件 \u0026lt;projection\u0026gt;定义了投射，可以只返回结果文档中的部分字段 # 读取全部文档 # 既不筛选，也不投射 \u0026gt; db.accounts.find() { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00c9672e77e7cb392a8fd\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;bob\u0026#34;, \u0026#34;balance\u0026#34; : 50 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8fe\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;charlie\u0026#34;, \u0026#34;balance\u0026#34; : 500 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8ff\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00f5272e77e7cb392a901\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;fred\u0026#34;, \u0026#34;balance\u0026#34; : 20 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce011fd72e77e7cb392a902\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34;, \u0026#34;balance\u0026#34; : 1000 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce0f15c72e77e7cb392a90c\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;001\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;002\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;alipay\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;003\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 500 } # 格式化结果 \u0026gt; db.accounts.find().pretty() { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00c9672e77e7cb392a8fd\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;bob\u0026#34;, \u0026#34;balance\u0026#34; : 50 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8fe\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;charlie\u0026#34;, \u0026#34;balance\u0026#34; : 500 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8ff\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00f5272e77e7cb392a901\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;fred\u0026#34;, \u0026#34;balance\u0026#34; : 20 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce011fd72e77e7cb392a902\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34;, \u0026#34;balance\u0026#34; : 1000 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce0f15c72e77e7cb392a90c\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;001\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;002\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;alipay\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;003\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 500 }   匹配查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  # 筛选文档 # 匹配查询 语法: { \u0026lt;field\u0026gt;: \u0026lt;value\u0026gt;, ... } # 读取 alice 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;alice\u0026#34; } ) { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;balance\u0026#34; : 100 } # 读取 alice 的余额为100元的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;alice\u0026#34;, balance: 100 } ) { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;balance\u0026#34; : 100 } # 读取 alice 的余额为200元的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;alice\u0026#34;, balance: 200 } ) 不存在 # 读取银行账户类型为 savings 的文档 (复合主键) \u0026gt; db.accounts.find( { \u0026#34;_id.type\u0026#34;: \u0026#34;savings\u0026#34; } ) { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;001\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;002\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 100 }   比较操作符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66  # 筛选文档 # 比较操作符 $eq equal $ne not equal $gt great than $gte great than or equal $lt less than $lte less than or equal 语法: { \u0026lt;field\u0026gt;: { $\u0026lt;operator\u0026gt;: \u0026lt;value\u0026gt; } } # 读取 alice 的银行账户文档 \u0026gt; db.accounts.find( { name: { $eq: \u0026#34;alice\u0026#34; } } ) { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;balance\u0026#34; : 100 } # 与 db.accounts.find( { name: \u0026#34;alice\u0026#34; } ) 的查询效果相同 # 读取不属于 alice 的银行账户文档 \u0026gt; db.accounts.find( { name: { $ne: \u0026#34;alice\u0026#34; } } ) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00c9672e77e7cb392a8fd\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;bob\u0026#34;, \u0026#34;balance\u0026#34; : 50 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8fe\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;charlie\u0026#34;, \u0026#34;balance\u0026#34; : 500 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8ff\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00f5272e77e7cb392a901\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;fred\u0026#34;, \u0026#34;balance\u0026#34; : 20 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce011fd72e77e7cb392a902\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34;, \u0026#34;balance\u0026#34; : 1000 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce0f15c72e77e7cb392a90c\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;001\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;002\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;alipay\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;003\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 500 } # 读取所有余额不等于100的银行账户文档 \u0026gt; db.accounts.find( { balance: { $ne: 100 } } ) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00c9672e77e7cb392a8fd\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;bob\u0026#34;, \u0026#34;balance\u0026#34; : 50 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8fe\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;charlie\u0026#34;, \u0026#34;balance\u0026#34; : 500 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8ff\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00f5272e77e7cb392a901\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;fred\u0026#34;, \u0026#34;balance\u0026#34; : 20 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce011fd72e77e7cb392a902\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34;, \u0026#34;balance\u0026#34; : 1000 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;001\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;alipay\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;003\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 500 } # 读取余额大于200的银行账户文档 \u0026gt; db.accounts.find( { balance: { $gt: 200 } } ) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8fe\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;charlie\u0026#34;, \u0026#34;balance\u0026#34; : 500 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce011fd72e77e7cb392a902\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34;, \u0026#34;balance\u0026#34; : 1000 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;alipay\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;003\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 500 } $in 匹配字段值与任一查询值相等的文档 $nin 匹配字段值与任何查询值都不相等的文档 语法: { \u0026lt;field\u0026gt;: { $in: [ \u0026lt;value1\u0026gt;, \u0026lt;value2\u0026gt;, ... ] } } # 读取 alice 和 charlie 的银行账户文档 \u0026gt; db.accounts.find( { name: { $in: [ \u0026#34;alice\u0026#34;, \u0026#34;charlie\u0026#34; ] } } ) { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8fe\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;charlie\u0026#34;, \u0026#34;balance\u0026#34; : 500 } # 读取除了 alice 和 charlie 以外的其他用户的银行账户文档 \u0026gt; db.accounts.find( { name: { $nin: [ \u0026#34;alice\u0026#34;, \u0026#34;charlie\u0026#34; ] } } ) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00c9672e77e7cb392a8fd\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;bob\u0026#34;, \u0026#34;balance\u0026#34; : 50 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8ff\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00f5272e77e7cb392a901\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;fred\u0026#34;, \u0026#34;balance\u0026#34; : 20 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce011fd72e77e7cb392a902\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34;, \u0026#34;balance\u0026#34; : 1000 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce0f15c72e77e7cb392a90c\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;001\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;002\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;alipay\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;003\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 500 }    注意: $ne会筛选出并不包含查询字段的文档比如，读取银行账户类型不是 savings 的文档: db.accounts.find( { \u0026quot;_id.type\u0026quot;: { $ne: \u0026quot;savings\u0026quot; } } )\n 1 2 3 4 5 6 7 8  { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00c9672e77e7cb392a8fd\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;bob\u0026#34;, \u0026#34;balance\u0026#34; : 50 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8fe\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;charlie\u0026#34;, \u0026#34;balance\u0026#34; : 500 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8ff\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00f5272e77e7cb392a901\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;fred\u0026#34;, \u0026#34;balance\u0026#34; : 20 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce011fd72e77e7cb392a902\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34;, \u0026#34;balance\u0026#34; : 1000 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce0f15c72e77e7cb392a90c\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;alipay\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;003\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 500 }    可以看到，结果中有很多文档并没有包含 _id.type 这个字段可以配合下面的 $exists 操作符一块使用与 $ne 类似，$nin 也会筛选出并不包含查询字段的文档比如，读取账户类型不是 savings 的银行账户文档: db.accounts.find( { \u0026quot;_id.type\u0026quot;: { $nin: [ \u0026quot;savings\u0026quot; ] } } )\n 1 2 3 4 5 6 7 8  { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00c9672e77e7cb392a8fd\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;bob\u0026#34;, \u0026#34;balance\u0026#34; : 50 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8fe\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;charlie\u0026#34;, \u0026#34;balance\u0026#34; : 500 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8ff\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00f5272e77e7cb392a901\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;fred\u0026#34;, \u0026#34;balance\u0026#34; : 20 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce011fd72e77e7cb392a902\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34;, \u0026#34;balance\u0026#34; : 1000 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce0f15c72e77e7cb392a90c\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;alipay\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;003\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 500 }    可以看到，结果中有很多文档并没有包含 _id.type 这个字段可以配合下面的 $exists 操作符一块使用 逻辑操作符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92  # 筛选文档 # 逻辑操作符查询 $not 匹配筛选条件不成立的文档 $and 匹配多个筛选条件全部成立的文档 $or 匹配至少一个筛选条件成立的文档 $nor 匹配多个筛选条件全部不成立的文档 $not 语法: { \u0026lt;field\u0026gt;: { $not: { \u0026lt;operator-expression\u0026gt; } } } # 读取余额不小于200的银行账户文档 \u0026gt; db.accounts.find( { balance: { $not: { $lt: 200 } } } ) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8fe\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;charlie\u0026#34;, \u0026#34;balance\u0026#34; : 500 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8ff\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce011fd72e77e7cb392a902\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34;, \u0026#34;balance\u0026#34; : 1000 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;001\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;alipay\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;003\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 500 } $and 语法: { $and: [ { \u0026lt;expression1\u0026gt; }, { \u0026lt;expression2\u0026gt; }, ... ] } # 读取余额大于100并且用户姓名排在 fred 之后的银行账户文档 \u0026gt; db.accounts.find({ $and: [ { balance: { $gt: 100 } }, { name: { $gt: \u0026#34;fred\u0026#34; } } ] }) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce011fd72e77e7cb392a902\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34;, \u0026#34;balance\u0026#34; : 1000 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;001\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;alipay\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;003\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 500 } # 当筛选条件应用在不同字段上时，可以省略 $and 操作符 \u0026gt; db.accounts.find( { balance: { $gt: 100 }, name: { $gt: \u0026#34;fred\u0026#34; } } ) 和上面的查询效果相同 # 当筛选条件应用在同一个字段上时，也可以简化命令 # 读取余额大于100并且小于500的银行账户文档 \u0026gt; db.accounts.find({ $and: [ { balance: { $gt: 100 } }, { balance: { $lt: 500 } } ] }) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8ff\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;001\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34;, \u0026#34;balance\u0026#34; : 200 } \u0026gt; db.accounts.find( { balance: { $gt: 100, $lt: 500 } } ) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8ff\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;001\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34;, \u0026#34;balance\u0026#34; : 200 } $or 语法:(与 $and 类似) { $or: [ { \u0026lt;expression1\u0026gt; }, { \u0026lt;expression2\u0026gt; }, ... ] } # 读取属于 alice 或者 charlie 的银行账户文档 \u0026gt; db.accounts.find({ $or: [ { name: { $eq: \u0026#34;alice\u0026#34; } }, { name: { $eq: \u0026#34;charlie\u0026#34; } } ] }) { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8fe\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;charlie\u0026#34;, \u0026#34;balance\u0026#34; : 500 } # 当所有筛选条件使用的都是 $eq 操作符时，$or 和 $in 的效果是相同的 \u0026gt; db.accounts.find( { name: { $in: [ \u0026#34;alice\u0026#34;, \u0026#34;charlie\u0026#34; ] } } ) { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8fe\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;charlie\u0026#34;, \u0026#34;balance\u0026#34; : 500 } # 读取余额小于100或者大于500的银行账户文档 \u0026gt; db.accounts.find({ $or: [ { balance: { $lt: 100 } }, { balance: { $gt: 500 } } ] }) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00c9672e77e7cb392a8fd\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;bob\u0026#34;, \u0026#34;balance\u0026#34; : 50 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00f5272e77e7cb392a901\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;fred\u0026#34;, \u0026#34;balance\u0026#34; : 20 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce011fd72e77e7cb392a902\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34;, \u0026#34;balance\u0026#34; : 1000 } $nor 语法:(与 $and 类似) { $nor: [ { \u0026lt;expression1\u0026gt; }, { \u0026lt;expression2\u0026gt; }, ... ] } # 读取不属于 alice 和 charlie 且余额不小于100的银行账户文档 \u0026gt; db.accounts.find({ $nor: [ { name: \u0026#34;alice\u0026#34; }, { name: \u0026#34;charlie\u0026#34; }, { balance: { $lt: 100 } } ] }) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8ff\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce011fd72e77e7cb392a902\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34;, \u0026#34;balance\u0026#34; : 1000 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce0f15c72e77e7cb392a90c\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;001\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;002\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;alipay\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;003\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 500 }    注意: $not 和 $nor 也会筛选出并不包含查询字段的文档可以配合下面的 $exists 操作符一块使用 字段操作符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  # 筛选文档 # 字段操作符 $exists 匹配包含查询字段的文档 $type 匹配字段类型符合查询值的文档 $exists 语法: { \u0026lt;field\u0026gt;: { $exists: \u0026lt;boolean\u0026gt; } } # 读取包含账户类型字段的银行账户文档 \u0026gt; db.accounts.find( { \u0026#34;_id.type\u0026#34;: { $exists: true } } ) { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;001\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;002\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;alipay\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;003\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 500 } \u0026gt; db.accounts.find( { \u0026#34;_id.type\u0026#34;: { $ne: \u0026#34;alipay\u0026#34;, $exists: true } } ) { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;001\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;002\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 100 } $type 语法: { \u0026lt;field\u0026gt;: { $type: \u0026lt;BSON type\u0026gt; } } { \u0026lt;field\u0026gt;: { $type: [ \u0026lt;BSON type1\u0026gt;, \u0026lt;BSON type2\u0026gt;, ... ] } } # 读取文档主键是字符串的银行账户文档 \u0026gt; db.accounts.find( { _id: { $type: \u0026#34;string\u0026#34; } } ) { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;balance\u0026#34; : 100 } # 读取文档主键是对象主键或者复合主键的银行账户文档 \u0026gt; db.accounts.find( { _id: { $type: [\u0026#34;objectId\u0026#34;, \u0026#34;object\u0026#34;] } } ) { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;alipay\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;003\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 500 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;001\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;002\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00c9672e77e7cb392a8fd\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;bob\u0026#34;, \u0026#34;balance\u0026#34; : 50 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8fe\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;charlie\u0026#34;, \u0026#34;balance\u0026#34; : 500 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8ff\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00f5272e77e7cb392a901\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;fred\u0026#34;, \u0026#34;balance\u0026#34; : 20 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce011fd72e77e7cb392a902\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34;, \u0026#34;balance\u0026#34; : 1000 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce0f15c72e77e7cb392a90c\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 100 } # 读取用户姓名是 null 的银行账户文档 \u0026gt; db.accounts.find( { name: { $type: \u0026#34;null\u0026#34; } } ) 除了使用BSON类型名称作为 $type 操作符的参数，我们还可以使用类型序号。比如 \u0026gt; db.accounts.find( { _id: { $type: 2 } } ) { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;balance\u0026#34; : 100 }   数组操作符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  # 筛选文档 # 数组操作符 $all 匹配数组字段中包含所有查询值的文档 $elemMatch 匹配数组字段中至少存在一个值满足筛选条件的文档 $all 语法: { \u0026lt;field\u0026gt;: { $all: [ \u0026lt;value1\u0026gt;, \u0026lt;value2\u0026gt;, ... ] } } # 首先，为了练习这个操作符，我们先创建一些包含数组和嵌套数组的文档 \u0026gt; db.accounts.insert([ { name: \u0026#34;jack\u0026#34;, balance: 2000, contact: [ \u0026#34;11111111\u0026#34;, \u0026#34;Alabama\u0026#34;, \u0026#34;US\u0026#34; ] }, { name: \u0026#34;karen\u0026#34;, balance: 2500, contact: [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ], \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34; ] } ]) BulkWriteResult({ \u0026#34;writeErrors\u0026#34; : [ ], \u0026#34;writeConcernErrors\u0026#34; : [ ], \u0026#34;nInserted\u0026#34; : 2, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nMatched\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 0, \u0026#34;nRemoved\u0026#34; : 0, \u0026#34;upserted\u0026#34; : [ ] }) # 读取联系地址位于中国北京的银行账户文档 \u0026gt; db.accounts.find( { contact: { $all: [ \u0026#34;China\u0026#34;, \u0026#34;Beijing\u0026#34; ] } } ) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1107d72e77e7cb392a90e\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;balance\u0026#34; : 2500, \u0026#34;contact\u0026#34; : [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ], \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34; ] } # 读取联系电话包含 22222222 和 33333333 的银行账户文档 \u0026gt; db.accounts.find( { contact: { $all: [ [\u0026#34;22222222\u0026#34;,\u0026#34;33333333\u0026#34;] ] } } ) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1107d72e77e7cb392a90e\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;balance\u0026#34; : 2500, \u0026#34;contact\u0026#34; : [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ], \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34; ] } \u0026gt; db.accounts.find( { contact: { $all: [ [\u0026#34;33333333\u0026#34;,\u0026#34;22222222\u0026#34;] ] } } ) 不匹配任何文档 $elemMatch 语法: { \u0026lt;field\u0026gt;: { $elemMatch: { \u0026lt;query1\u0026gt;, \u0026lt;query2\u0026gt;, ... } } } # 读取联系电话范围在 10000000 至 20000000 之间的银行账户文档 \u0026gt; db.accounts.find( { contact: { $elemMatch: { $gt: \u0026#34;10000000\u0026#34;, $lt: \u0026#34;20000000\u0026#34; } } } ) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1107d72e77e7cb392a90d\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;jack\u0026#34;, \u0026#34;balance\u0026#34; : 2000, \u0026#34;contact\u0026#34; : [ \u0026#34;11111111\u0026#34;, \u0026#34;Alabama\u0026#34;, \u0026#34;US\u0026#34; ] } # 读取包含一个在 10000000 至 20000000 之间，和一个在 20000000 至 30000000 之间的联系电话的银行账户文档 \u0026gt; db.accounts.find( { contact: { $all: [ { $elemMatch: { $gt: \u0026#34;10000000\u0026#34;, $lt: \u0026#34;20000000\u0026#34; } }, { $elemMatch: { $gt: \u0026#34;20000000\u0026#34;, $lt: \u0026#34;30000000\u0026#34; } } ] } } )   运算操作符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  # 筛选文档 # 运算操作符 $regex 匹配满足正则表达式的文档 语法: { \u0026lt;field\u0026gt;: { $regex: /pattern/, $options: \u0026#34;\u0026lt;options\u0026gt;\u0026#34; } } # 大部分场景使用该语法 { \u0026lt;field\u0026gt;: /pattern/\u0026lt;options\u0026gt; } # 特定场景使用该语法 兼容 PCRE v8.41 正则表达式库 在与 $in 操作符配合使用时，只能使用 /pattern/\u0026lt;options\u0026gt; 语法 # 读取用户姓名以 c 或者 j 开头的银行账户文档 \u0026gt; db.accounts.find( { name: { $in: [ /^c/, /^j/ ] } } ) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8fe\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;charlie\u0026#34;, \u0026#34;balance\u0026#34; : 500 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce0f15c72e77e7cb392a90c\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;001\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1107d72e77e7cb392a90d\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;jack\u0026#34;, \u0026#34;balance\u0026#34; : 2000, \u0026#34;contact\u0026#34; : [ \u0026#34;11111111\u0026#34;, \u0026#34;Alabama\u0026#34;, \u0026#34;US\u0026#34; ] } # 读取用户姓名包含 LIE (不区分大小写)的银行账户文档 \u0026gt; db.accounts.find( { name: { $regex: /LIE/, $options: \u0026#39;i\u0026#39; } } ) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8fe\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;charlie\u0026#34;, \u0026#34;balance\u0026#34; : 500 } \u0026gt; db.accounts.find( { name: /LIE/i } ) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8fe\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;charlie\u0026#34;, \u0026#34;balance\u0026#34; : 500 }   文档游标 db.collection.find() 返回的是一个文档集合游标\n在不迭代游标的情况下，只列出前20个文档:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026gt; var myCursor = db.accounts.find(); \u0026gt; myCursor { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00c9672e77e7cb392a8fd\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;bob\u0026#34;, \u0026#34;balance\u0026#34; : 50 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8fe\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;charlie\u0026#34;, \u0026#34;balance\u0026#34; : 500 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8ff\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00f5272e77e7cb392a901\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;fred\u0026#34;, \u0026#34;balance\u0026#34; : 20 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce011fd72e77e7cb392a902\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34;, \u0026#34;balance\u0026#34; : 1000 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce0f15c72e77e7cb392a90c\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;001\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;002\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;alipay\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;003\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 500 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1107d72e77e7cb392a90d\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;jack\u0026#34;, \u0026#34;balance\u0026#34; : 2000, \u0026#34;contact\u0026#34; : [ \u0026#34;11111111\u0026#34;, \u0026#34;Alabama\u0026#34;, \u0026#34;US\u0026#34; ] } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1107d72e77e7cb392a90e\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;balance\u0026#34; : 2500, \u0026#34;contact\u0026#34; : [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ], \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34; ] } // 这里由于我们的文档总数不足20，所以看不出效果   我们也可以使用游标下标直接访问文档集合中的某一个文档，下标从0开始:\n1 2 3 4 5 6 7  \u0026gt; var myCursor = db.accounts.find(); \u0026gt; myCursor[1] { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00c9672e77e7cb392a8fd\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;bob\u0026#34;, \u0026#34;balance\u0026#34; : 50 }   默认情况下，遍历完游标中所有的文档之后，或者在10分钟之后，游标便会自动关闭\n我们可以使用 noCursorTimeout() 函数来保持游标一直有效\n1  \u0026gt; var myCursor = db.accounts.find().noCursorTimeout();   在这之后，如果我们遍历完了游标，游标会自动关闭。但是如果在不遍历游标的情况下，需要主动关闭游标\n1  \u0026gt; myCursor.close();   游标函数 1 2 3 4 5 6 7  cursor.hasNext() cursor.next() cursor.forEach() cursor.limit() cursor.skip() cursor.count() cursor.sort()   hasNext 和 next 函数  hasNext 和 next 用于遍历游标\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026gt; var myCursor = db.accounts.find({ balance: 100 }); \u0026gt; while( myCursor.hasNext() ) { printjson(myCursor.next()); } { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce0f15c72e77e7cb392a90c\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;002\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 100 }   forEach 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026gt; var myCursor = db.accounts.find({ balance: 100 }); \u0026gt; myCursor.forEach(printjson); { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce0f15c72e77e7cb392a90c\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;002\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 100 }   limit 和 skip 函数  这两个函数通常用于分页\n 1 2 3 4 5 6 7 8  cursor.limit(\u0026lt;number\u0026gt;) cursor.skip(\u0026lt;offset\u0026gt;) \u0026gt; db.accounts.find({ balance: 100 }).limit(1) { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;balance\u0026#34; : 100 } \u0026gt; db.accounts.find({ balance: 100 }).skip(1) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce0f15c72e77e7cb392a90c\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;002\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 100 }    问题: 如果使用 cursor.limit(0) 会返回什么结果呢？答案:  1 2 3  { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce0f15c72e77e7cb392a90c\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;002\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 100 }    不对游标进行任何限制，与 limit() 以及不进行调用效果相同。也就是说，默认返回前20个文档？\n count 函数 1  cursor.count(\u0026lt;applySkipLimit\u0026gt;)   默认情况下，\u0026lt;applySkipLimit\u0026gt; 为 false，即 cursor.count() 不会考虑 cursor.skip() 和 cursor.limit() 的效果\n1 2 3 4 5 6 7 8 9 10  \u0026gt; db.accounts.find({ balance: 100 }) { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce0f15c72e77e7cb392a90c\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;002\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 100 } \u0026gt; db.accounts.find({ balance: 100 }).limit(1).count() 3 \u0026gt; db.accounts.find({ balance: 100 }).limit(1).count(true) 1   1 2 3 4 5 6 7 8  # 在不提供筛选条件时，cursor.count() 会从集合的元数据 Metadata 中取得结果，而不会遍历集合 \u0026gt; db.accounts.find().count() 22 \u0026gt; db.accounts.count() 22 # 当数据库分布式结构较为复杂时，元数据中的文档数量可能不准确 # 在这种情况下，应该避免使用不提供筛选条件的 cursor.count() 函数，而使用聚合管道来计算文档数量   sort 函数 1  cursor.sort(\u0026lt;document\u0026gt;)   这里的 \u0026lt;document\u0026gt; 定义了排序的要求，{ field: ordering}\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  1表示递增排序 -1表示递减排序 # 按照余额从大到小，用户姓名按字母排序的方式排列银行账户文档 \u0026gt; db.accounts.find().sort( { balance: -1, name: 1 } ) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1107d72e77e7cb392a90e\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;balance\u0026#34; : 2500, \u0026#34;contact\u0026#34; : [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ], \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34; ] } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1107d72e77e7cb392a90d\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;jack\u0026#34;, \u0026#34;balance\u0026#34; : 2000, \u0026#34;contact\u0026#34; : [ \u0026#34;11111111\u0026#34;, \u0026#34;Alabama\u0026#34;, \u0026#34;US\u0026#34; ] } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce011fd72e77e7cb392a902\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34;, \u0026#34;balance\u0026#34; : 1000 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8fe\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;charlie\u0026#34;, \u0026#34;balance\u0026#34; : 500 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;alipay\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;003\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 500 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1225972e77e7cb392a90f\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1225b72e77e7cb392a910\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1225c72e77e7cb392a911\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1225d72e77e7cb392a912\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1225d72e77e7cb392a913\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1225e72e77e7cb392a914\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1226b72e77e7cb392a915\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1226b72e77e7cb392a916\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1226c72e77e7cb392a917\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1226d72e77e7cb392a918\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8ff\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;001\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce0f15c72e77e7cb392a90c\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;002\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 100 } Type \u0026#34;it\u0026#34; for more \u0026gt; it { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00c9672e77e7cb392a8fd\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;bob\u0026#34;, \u0026#34;balance\u0026#34; : 50 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00f5272e77e7cb392a901\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;fred\u0026#34;, \u0026#34;balance\u0026#34; : 20 } # 读取余额最大的银行账户文档 \u0026gt; db.accounts.find().sort({ balance: -1 }).limit(1) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1107d72e77e7cb392a90e\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;balance\u0026#34; : 2500, \u0026#34;contact\u0026#34; : [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ], \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34; ] }    注意: cursor.skip(), cursor.limit(), cursor.sort()的执行顺序原则一: cursor.skip()永远在cursor.limit()之前执行 1  \u0026gt; db.accounts.find().limit(5).skip(3)    从书写顺序看，是先执行了limit(5)拿到5条数据，然后执行skip(3)跳过3条数据，结果就剩2条数据了。但是执行结果如下 1 2 3 4 5  { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8ff\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00f5272e77e7cb392a901\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;fred\u0026#34;, \u0026#34;balance\u0026#34; : 20 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce011fd72e77e7cb392a902\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34;, \u0026#34;balance\u0026#34; : 1000 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce0f15c72e77e7cb392a90c\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;001\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34;, \u0026#34;balance\u0026#34; : 200 }    实际执行顺序是，find()拿到所有文档数量，skip(3)跳过前3条，然后limit(5)取出接下来的5条数据原则二: cursor.sort()永远在cursor.skip()和cursor.limit()之前执行 1  \u0026gt; db.accounts.find().skip(3).limit(5).sort({ balance: -1 })    先执行sort({ balance: -1 })按照余额降序排序，然后执行skip(3)跳过前3条，最后执行limit(5)取出接下来的5条数据与 db.accounts.find().limit(5).skip(3).sort({ balance: -1 })的结果相同，不管书写顺序如何，执行顺序永远是:sort() \u0026gt; skip() \u0026gt; limit() 文档投射 1  db.collection.find(\u0026lt;query\u0026gt;, \u0026lt;projection\u0026gt;)   不使用投射时，db.collection.find()返回符合筛选条件的完整文档，而使用投射可以有选择性的返回文档中的部分字段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  projection: { field: inclusion } 1 表示返回该字段 0 表示不返回该字段 # 只返回银行账户文档中的用户姓名 \u0026gt; db.accounts.find({}, { name: 1 }) { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34; } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00c9672e77e7cb392a8fd\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;bob\u0026#34; } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8fe\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;charlie\u0026#34; } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8ff\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34; } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00f5272e77e7cb392a901\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;fred\u0026#34; } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce011fd72e77e7cb392a902\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34; } # 只返回银行账户文档中的用户姓名(不包含文档主键) \u0026gt; db.accounts.find({}, { name: 1, _id: 0 }) { \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;bob\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;charlie\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;fred\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34; } # 不返回银行账户文档中的用户姓名(也不返回文档主键) \u0026gt; db.accounts.find({}, { name: 0, _id: 0 }) { \u0026#34;balance\u0026#34; : 100 } { \u0026#34;balance\u0026#34; : 200 } { \u0026#34;balance\u0026#34; : 100 } { \u0026#34;balance\u0026#34; : 500 } { \u0026#34;balance\u0026#34; : 2000, \u0026#34;contact\u0026#34; : [ \u0026#34;11111111\u0026#34;, \u0026#34;Alabama\u0026#34;, \u0026#34;US\u0026#34; ] } { \u0026#34;balance\u0026#34; : 2500, \u0026#34;contact\u0026#34; : [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ], \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34; ] }    注意: projection参数不能混用包含与不包含这两种投射操作，文档主键除外 1 2 3 4 5 6 7  \u0026gt; db.accounts.find({}, { name: 1, balance: 0, _id: 0 }) Error: error: { \u0026#34;ok\u0026#34; : 0, \u0026#34;errmsg\u0026#34; : \u0026#34;Projection cannot have a mix of inclusion and exclusion.\u0026#34;, \u0026#34;code\u0026#34; : 2, \u0026#34;codeName\u0026#34; : \u0026#34;BadValue\u0026#34; }   在数组字段上使用投射 $slice操作符可以返回数组字段中的部分元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  # 不使用 slice 操作符 \u0026gt; db.accounts.find({}, { _id: 0, name: 1, contact: 1 }) { \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;jack\u0026#34;, \u0026#34;contact\u0026#34; : [ \u0026#34;11111111\u0026#34;, \u0026#34;Alabama\u0026#34;, \u0026#34;US\u0026#34; ] } { \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;contact\u0026#34; : [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ], \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34; ] } # 返回 contact 字段的第一个元素 \u0026gt; db.accounts.find({}, { _id: 0, name: 1, contact: { $slice: 1 } }) { \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;jack\u0026#34;, \u0026#34;contact\u0026#34; : [ \u0026#34;11111111\u0026#34; ] } { \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;contact\u0026#34; : [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ] ] } # 返回 contact 字段最后一个元素 \u0026gt; db.accounts.find({}, { _id: 0, name: 1, contact: { $slice: -1 } }) { \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;jack\u0026#34;, \u0026#34;contact\u0026#34; : [ \u0026#34;US\u0026#34; ] } { \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;contact\u0026#34; : [ \u0026#34;China\u0026#34; ] } # 返回 contact 字段的最后两个元素 \u0026gt; db.accounts.find({}, { _id: 0, name: 1, contact: { $slice: -2 } }) { \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;jack\u0026#34;, \u0026#34;contact\u0026#34; : [ \u0026#34;Alabama\u0026#34;, \u0026#34;US\u0026#34; ] } { \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;contact\u0026#34; : [ \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34; ] } # 对 contact 字段先执行一个 skip(1) 操作，然后执行 limit(2) 操作 \u0026gt; db.accounts.find({}, { _id: 0, name: 1, contact: { $slice: [1, 2] } }) { \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;jack\u0026#34;, \u0026#34;contact\u0026#34; : [ \u0026#34;Alabama\u0026#34;, \u0026#34;US\u0026#34; ] } { \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;contact\u0026#34; : [ \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34; ] }   $elemMatch和$操作符可以返回数组字段中，满足筛选条件的第一个元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  # 返回 contact 中大于 Alabama 的第一个元素 \u0026gt; db.accounts.find({}, { _id: 0, name: 1, contact: { $elemMatch: { $gt: \u0026#34;Alabama\u0026#34; } } }) { \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;jack\u0026#34;, \u0026#34;contact\u0026#34; : [ \u0026#34;US\u0026#34; ] } { \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;contact\u0026#34; : [ \u0026#34;Beijing\u0026#34; ] } # 使用\u0026lt;query\u0026gt;参数中 contact 的筛选条件作为 projection 中 contact 的投射操作 # 是上面 $elemMatch 的简写形式 \u0026gt; db.accounts.find({ contact: { $gt: \u0026#34;Alabama\u0026#34; } }, { _id: 0, name: 1, \u0026#34;contact.$\u0026#34;: 1 # contact: { $elemMatch: { $gt: \u0026#34;Alabama\u0026#34; } } 的简写形式？ })    ？疑问 1  \u0026gt; db.accounts.find({ contact: { $gt: \u0026#34;Alabama\u0026#34; } })    是查询出contact字段大于字符串Alabama的文档，但是contact是数组类型，数组是如何与字符串进行比较操作的？\n 更新文档 ¶ 1 2 3 4 5 6 7 8  语法: db.\u0026lt;collection\u0026gt;.update(\u0026lt;query\u0026gt;, \u0026lt;update\u0026gt;, \u0026lt;options\u0026gt;) # \u0026lt;query\u0026gt; 文档定义了更新文档时筛选文档的条件，也就是说，要更新哪些文档 # 与 db.collection.find() 中的 query 相同 # \u0026lt;update\u0026gt; 文档提供了更新的内容，也就是说，要进行什么样的更新 # \u0026lt;options\u0026gt; 文档声明了一些应用于更新操作的选项和参数   更新整篇文档 1 2 3 4 5 6 7 8 9 10 11 12 13 14  # 如果 \u0026lt;update\u0026gt; 文档不包含任何更新操作符，则会更新整个文档。 # 执行的是替换操作 # 检查 alice 的银行账户文档 \u0026gt; db.accounts.find({ name: \u0026#34;alice\u0026#34; }) { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;balance\u0026#34; : 100 } # 将 alice 的账户余额更改为123 \u0026gt; db.accounts.update({ name: \u0026#34;alice\u0026#34; }, { name: \u0026#34;alice\u0026#34;, balance: 123 }) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 检查 alice 的银行账户文档 \u0026gt; db.accounts.find({ name: \u0026#34;alice\u0026#34; }) { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;balance\u0026#34; : 123 }    注意: 第一，文档主键 _id 在任何情况下都是不可以更改的如果我们在 \u0026lt;update\u0026gt;文档中包含_id字段，则_id值一定要和被更新文档的_id值保持一致 1 2  \u0026gt; db.accounts.update({ name: \u0026#34;alice\u0026#34; }, { _id: \u0026#34;account1\u0026#34;, name: \u0026#34;alice\u0026#34;, balance: 100 }) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 })    如果\u0026lt;update\u0026gt;文档中包含的_id字段和被更新的文档_id值不一致，则会更新失败 1 2 3 4 5 6 7 8 9 10  \u0026gt; db.accounts.update({ name: \u0026#34;alice\u0026#34; }, { _id: \u0026#34;account2\u0026#34;, name: \u0026#34;alice\u0026#34;, balance: 123 }) WriteResult({ \u0026#34;nMatched\u0026#34; : 0, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 0, \u0026#34;writeError\u0026#34; : { \u0026#34;code\u0026#34; : 66, \u0026#34;errmsg\u0026#34; : \u0026#34;After applying the update, the (immutable) field \u0026#39;_id\u0026#39; was found to have been altered to _id: \\\u0026#34;account2\\\u0026#34;\u0026#34; } })    第二，在使用\u0026lt;update\u0026gt;文档替换整篇被更新文档时，只有第一篇符合\u0026lt;query\u0026gt;筛选条件的文档才会被更新\n 1 2 3 4 5 6 7 8 9 10 11 12 13  # 查看账户余额在0到100之间的账户文档 \u0026gt; db.accounts.find({ balance: { $gt: 0, $lt: 100 } }) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00c9672e77e7cb392a8fd\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;bob\u0026#34;, \u0026#34;balance\u0026#34; : 50 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00f5272e77e7cb392a901\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;fred\u0026#34;, \u0026#34;balance\u0026#34; : 20 } # 更新账户余额在0到100之间的账户文档 \u0026gt; db.accounts.update({ balance: { $gt: 0, $lt: 100 } }, { name: \u0026#34;bill\u0026#34;, balance: 80, gender: \u0026#34;M\u0026#34; } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 再次查看账户余额在0到100之间的账户文档 \u0026gt; db.accounts.find({ balance: { $gt: 0, $lt: 100 } }) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00c9672e77e7cb392a8fd\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;bill\u0026#34;, \u0026#34;balance\u0026#34; : 80, \u0026#34;gender\u0026#34; : \u0026#34;M\u0026#34; } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00f5272e77e7cb392a901\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;fred\u0026#34;, \u0026#34;balance\u0026#34; : 20 }    也就是说，更新整篇文档的操作，只能应用在单一文档上\n 更新特定字段 如果\u0026lt;update\u0026gt;文档只包含更新操作符，db.collection.update()将会使用\u0026lt;update\u0026gt;文档更新集合中符合\u0026lt;query\u0026gt;筛选条件的所有文档中的特定字段\n1 2 3 4 5 6 7 8 9  # 文档更新操作符 $set 更新或新增字段 $unset 删除字段 $rename 重命名字段 $inc 加减字段值 $mul 相乘字段值 $min 比较减小字段值 $max 比较增大字段值   $set操作符 更新或新增字段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173  语法: { $set: { \u0026lt;field1\u0026gt;: \u0026lt;value1\u0026gt;, \u0026lt;field2\u0026gt;: \u0026lt;value2\u0026gt;, ... } } # 查看 jack 的银行账户文档 \u0026gt; db.accounts.find({ name: \u0026#34;jack\u0026#34; }).pretty() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1107d72e77e7cb392a90d\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;jack\u0026#34;, \u0026#34;balance\u0026#34; : 2000, \u0026#34;contact\u0026#34; : [ \u0026#34;11111111\u0026#34;, \u0026#34;Alabama\u0026#34;, \u0026#34;US\u0026#34; ] } # 更新 jack 的银行账户余额和开户信息 \u0026gt; db.accounts.update( { name: \u0026#34;jack\u0026#34; }, { $set: { balance: 3000, info: { dateOpened: new Date(\u0026#34;2019-05-18T16:00:00Z\u0026#34;), branch: \u0026#34;branch1\u0026#34; } } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 再次查看 jack 的银行账户文档 \u0026gt; db.accounts.find({ name: \u0026#34;jack\u0026#34; }).pretty() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1107d72e77e7cb392a90d\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;jack\u0026#34;, \u0026#34;balance\u0026#34; : 3000, \u0026#34;contact\u0026#34; : [ \u0026#34;11111111\u0026#34;, \u0026#34;Alabama\u0026#34;, \u0026#34;US\u0026#34; ], \u0026#34;info\u0026#34; : { \u0026#34;dateOpened\u0026#34; : ISODate(\u0026#34;2019-05-18T16:00:00Z\u0026#34;), \u0026#34;branch\u0026#34; : \u0026#34;branch1\u0026#34; } } ## 更新或新增内嵌文档的字段 # 更新 jack 的银行账户的开户时间 \u0026gt; db.accounts.update( { name: \u0026#34;jack\u0026#34; }, { $set: { \u0026#34;info.dateOpened\u0026#34;: new Date(\u0026#34;2017-01-01T16:00:00Z\u0026#34;) } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 再次查看 jack 的银行账户文档 \u0026gt; db.accounts.find({ name: \u0026#34;jack\u0026#34; }).pretty() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1107d72e77e7cb392a90d\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;jack\u0026#34;, \u0026#34;balance\u0026#34; : 3000, \u0026#34;contact\u0026#34; : [ \u0026#34;11111111\u0026#34;, \u0026#34;Alabama\u0026#34;, \u0026#34;US\u0026#34; ], \u0026#34;info\u0026#34; : { \u0026#34;dateOpened\u0026#34; : ISODate(\u0026#34;2017-01-01T16:00:00Z\u0026#34;), \u0026#34;branch\u0026#34; : \u0026#34;branch1\u0026#34; } } ## 更新或新增数组内的元素 # 更新 jack 的联系电话 \u0026gt; db.accounts.update( { name: \u0026#34;jack\u0026#34; }, { $set: { \u0026#34;contact.0\u0026#34;: \u0026#34;66666666\u0026#34; } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 再次查看 jack 的银行账户文档 \u0026gt; db.accounts.find({ name: \u0026#34;jack\u0026#34; }).pretty() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1107d72e77e7cb392a90d\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;jack\u0026#34;, \u0026#34;balance\u0026#34; : 3000, \u0026#34;contact\u0026#34; : [ \u0026#34;66666666\u0026#34;, \u0026#34;Alabama\u0026#34;, \u0026#34;US\u0026#34; ], \u0026#34;info\u0026#34; : { \u0026#34;dateOpened\u0026#34; : ISODate(\u0026#34;2017-01-01T16:00:00Z\u0026#34;), \u0026#34;branch\u0026#34; : \u0026#34;branch1\u0026#34; } } # 添加 jack 的联系方式 \u0026gt; db.accounts.update( { name: \u0026#34;jack\u0026#34; }, { $set: { \u0026#34;contact.3\u0026#34;: \u0026#34;new contact\u0026#34; } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 再次查看 jack 的银行账户文档 \u0026gt; db.accounts.find({ name: \u0026#34;jack\u0026#34; }).pretty() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1107d72e77e7cb392a90d\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;jack\u0026#34;, \u0026#34;balance\u0026#34; : 3000, \u0026#34;contact\u0026#34; : [ \u0026#34;66666666\u0026#34;, \u0026#34;Alabama\u0026#34;, \u0026#34;US\u0026#34;, \u0026#34;new contact\u0026#34; ], \u0026#34;info\u0026#34; : { \u0026#34;dateOpened\u0026#34; : ISODate(\u0026#34;2017-01-01T16:00:00Z\u0026#34;), \u0026#34;branch\u0026#34; : \u0026#34;branch1\u0026#34; } } # 数组索引可以随便设置 \u0026gt; db.accounts.update( { name: \u0026#34;jack\u0026#34; }, { $set: { \u0026#34;contact.10\u0026#34;: \u0026#34;new contact 10\u0026#34; } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) \u0026gt; db.accounts.find({ name: \u0026#34;jack\u0026#34; }).pretty() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1107d72e77e7cb392a90d\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;jack\u0026#34;, \u0026#34;balance\u0026#34; : 3000, \u0026#34;contact\u0026#34; : [ \u0026#34;66666666\u0026#34;, \u0026#34;Alabama\u0026#34;, \u0026#34;US\u0026#34;, \u0026#34;new contact\u0026#34;, null, null, null, null, null, null, \u0026#34;new contact10\u0026#34; ], \u0026#34;info\u0026#34; : { \u0026#34;dateOpened\u0026#34; : ISODate(\u0026#34;2017-01-01T16:00:00Z\u0026#34;), \u0026#34;branch\u0026#34; : \u0026#34;branch1\u0026#34; } }    注意: 如果向现有数组字段范围以外的位置添加新值，数组字段的长度会扩大，未被赋值的数组成员将被设置为null\n $unset 操作符 删除字段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  语法: { $unset: { \u0026lt;field1\u0026gt;: \u0026#34;\u0026#34;, \u0026lt;field2\u0026gt;: \u0026#34;\u0026#34;, ... } } # 删除 jack 的银行账户余额和开户地点 \u0026gt; db.accounts.update( { name: \u0026#34;jack\u0026#34; }, { $unset: { balance: \u0026#34;\u0026#34;, \u0026#34;info.branch\u0026#34;: \u0026#34;\u0026#34; } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 再次查看 jack 的银行账户文档 \u0026gt; db.accounts.find({ name: \u0026#34;jack\u0026#34; }).pretty() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1107d72e77e7cb392a90d\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;jack\u0026#34;, \u0026#34;contact\u0026#34; : [ \u0026#34;66666666\u0026#34;, \u0026#34;Alabama\u0026#34;, \u0026#34;US\u0026#34;, \u0026#34;new contact2\u0026#34;, null, null, null, null, null, null, \u0026#34;new contact10\u0026#34; ], \u0026#34;info\u0026#34; : { \u0026#34;dateOpened\u0026#34; : ISODate(\u0026#34;2017-01-01T16:00:00Z\u0026#34;) } } ## 删除数组内的字段 # 删除 jack 的联系电话 \u0026gt; db.accounts.update( { name: \u0026#34;jack\u0026#34; }, { $unset: { \u0026#34;contact.0\u0026#34;: \u0026#34;\u0026#34; } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 再次查看 jack 的银行账户文档 \u0026gt; db.accounts.find({ name: \u0026#34;jack\u0026#34; }).pretty() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1107d72e77e7cb392a90d\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;jack\u0026#34;, \u0026#34;contact\u0026#34; : [ null, \u0026#34;Alabama\u0026#34;, \u0026#34;US\u0026#34;, \u0026#34;new contact2\u0026#34;, null, null, null, null, null, null, \u0026#34;new contact10\u0026#34; ], \u0026#34;info\u0026#34; : { } }    注意: $unset操作符中的赋值(\u0026quot;\u0026quot;)对操作结果并没有任何影响\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  # 删除 jack 的银行开户时间 \u0026gt; db.accounts.update( { name: \u0026#34;jack\u0026#34; }, { $unset: { \u0026#34;info.dateOpened\u0026#34;: \u0026#34;this can be any value\u0026#34; } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 再次查看 jack 的银行账户文档 \u0026gt; db.accounts.find({ name: \u0026#34;jack\u0026#34; }).pretty() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1107d72e77e7cb392a90d\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;jack\u0026#34;, \u0026#34;contact\u0026#34; : [ \u0026#34;66666666\u0026#34;, \u0026#34;Alabama\u0026#34;, \u0026#34;US\u0026#34;, \u0026#34;new contact2\u0026#34;, null, null, null, null, null, null, \u0026#34;new contact10\u0026#34; ], \u0026#34;info\u0026#34; : { } }    如果$unset命令中的字段根本不存在，那么文档内容将保持不变 1 2 3 4 5 6 7 8 9  \u0026gt; db.accounts.update( { name: \u0026#34;jack\u0026#34; }, { $unset: { notExist: \u0026#34;\u0026#34; } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 0 })    当使用$unset命令删除数组字段中的某一个元素时，这个元素不会被删除，只会被赋以null值，而数组的长度不会改变\n $rename 操作符 重命名字段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123  语法: { $rename: { \u0026lt;field1\u0026gt;: \u0026lt;newName1\u0026gt;, \u0026lt;field2\u0026gt;: \u0026lt;newName2\u0026gt;, ... } } ## 重命名内嵌文档的字段 # 更新 karen 的银行账户的开户时间和联系方式 \u0026gt; db.accounts.update( { name: \u0026#34;karen\u0026#34; }, { $set: { info: { dateOpened: new Date(\u0026#34;2017-01-01T16:00:00Z\u0026#34;), branch: \u0026#34;branch1\u0026#34; }, \u0026#34;contact.3\u0026#34;: { primaryEmail: \u0026#34;xxx@gmail.com\u0026#34;, secondaryEmail: \u0026#34;yyy@gmail.com\u0026#34; } } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 karen 的银行账户文档 \u0026gt; db.accounts.find({ name: \u0026#34;karen\u0026#34; }).pretty() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1107d72e77e7cb392a90e\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;balance\u0026#34; : 2500, \u0026#34;contact\u0026#34; : [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ], \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34;, { \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34;, \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34; } ], \u0026#34;info\u0026#34; : { \u0026#34;dateOpened\u0026#34; : ISODate(\u0026#34;2017-01-01T16:00:00Z\u0026#34;), \u0026#34;branch\u0026#34; : \u0026#34;branch1\u0026#34; } } # 更新账户余额和开户地点字段在文档中的位置 \u0026gt; db.accounts.update( { name: \u0026#34;karen\u0026#34; }, { $rename: { \u0026#34;info.branch\u0026#34;: \u0026#34;branch\u0026#34;, \u0026#34;balance\u0026#34;: \u0026#34;info.balance\u0026#34; } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 karen 的银行账户文档 \u0026gt; db.accounts.find({ name: \u0026#34;karen\u0026#34; }).pretty() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1107d72e77e7cb392a90e\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;contact\u0026#34; : [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ], \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34;, { \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34;, \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34; } ], \u0026#34;info\u0026#34; : { \u0026#34;dateOpened\u0026#34; : ISODate(\u0026#34;2017-01-01T16:00:00Z\u0026#34;), \u0026#34;balance\u0026#34; : 2500 }, \u0026#34;branch\u0026#34; : \u0026#34;branch1\u0026#34; } ## 重命名数组中内嵌文档的字段 # 更新 karen 的联系方式 \u0026gt; db.accounts.update( { name: \u0026#34;karen\u0026#34; }, { $rename: { \u0026#34;contact.3.primaryEmail\u0026#34;: \u0026#34;primaryEmail\u0026#34; } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 0, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 0, \u0026#34;writeError\u0026#34; : { \u0026#34;code\u0026#34; : 2, \u0026#34;errmsg\u0026#34; : \u0026#34;The source field cannot be an array element, \u0026#39;contact.3.primaryEmail\u0026#39; in doc with _id: ObjectId(\u0026#39;5ce1107d72e77e7cb392a90e\u0026#39;) has an array field called \u0026#39;contact\u0026#39;\u0026#34; } }) # 反向操作 \u0026gt; db.accounts.update( { name: \u0026#34;karen\u0026#34; }, { $rename: { \u0026#34;branch\u0026#34;: \u0026#34;contact.3.branch\u0026#34; } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 0, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 0, \u0026#34;writeError\u0026#34; : { \u0026#34;code\u0026#34; : 2, \u0026#34;errmsg\u0026#34; : \u0026#34;The destination field cannot be an array element, \u0026#39;contact.3.branch\u0026#39; in doc with _id: ObjectId(\u0026#39;5ce1107d72e77e7cb392a90e\u0026#39;) has an array field called \u0026#39;contact\u0026#39;\u0026#34; } })    注意: 如果$rename命令要重命名的字段在文档中并不存在，那么文档内容不会发生任何改变\n 1 2 3 4 5 6 7 8 9  \u0026gt; db.accounts.update( { name: \u0026#34;jack\u0026#34; }, { $rename: { notExist: \u0026#34;name\u0026#34; } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 0 })    如果新的字段名已经存在，那么原有的这个字段会被覆盖\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026gt; db.accounts.update( { name: \u0026#34;jack\u0026#34; }, { $rename: { name: \u0026#34;contact\u0026#34; } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) \u0026gt; db.accounts.find({ name: \u0026#34;jack\u0026#34; }).pretty() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1107d72e77e7cb392a90d\u0026#34;), \u0026#34;contact\u0026#34; : \u0026#34;jack\u0026#34;, \u0026#34;info\u0026#34; : { } # 原来的 contact 内容不见了!!! }    当$rename命令中的新字段存在的时候，$rename命令会先$unset新旧字段，然后再$set新字段$rename命令中的旧字段和新字段都不可以指向数组元素 $inc 和 $mul 操作符 更新字段值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  语法: { $inc: { \u0026lt;field1\u0026gt;: \u0026lt;amount1\u0026gt;, ... } } { $mul: { \u0026lt;field1\u0026gt;: \u0026lt;amount1\u0026gt;, ... } } # 查看 david 的银行账户文档 \u0026gt; db.accounts.find({ name: \u0026#34;david\u0026#34; }) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8ff\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34;, \u0026#34;balance\u0026#34; : 200 } # 更新 david 的账户余额 \u0026gt; db.accounts.update( { name: \u0026#34;david\u0026#34; }, { $inc: { balance: -0.5 } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 david 的银行账户文档 \u0026gt; db.accounts.find({ name: \u0026#34;david\u0026#34; }) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8ff\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34;, \u0026#34;balance\u0026#34; : 199.5 } # 更新 david 的账户余额 \u0026gt; db.accounts.update( { name: \u0026#34;david\u0026#34; }, { $mul: { balance: 0.5 } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 david 的银行账户文档 \u0026gt; db.accounts.find({ name: \u0026#34;david\u0026#34; }) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8ff\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34;, \u0026#34;balance\u0026#34; : 99.75 }    注意: $inc和$mul命令只能应用在数字字段上\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026gt; db.accounts.update( { name: \u0026#34;david\u0026#34; }, { $inc: { name: -0.5 } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 0, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 0, \u0026#34;writeError\u0026#34; : { \u0026#34;code\u0026#34; : 14, \u0026#34;errmsg\u0026#34; : \u0026#34;Cannot apply $incto a value of non-numeric type. {_id: ObjectId(\u0026#39;5ce00d5972e77e7cb392a8ff\u0026#39;)} has the field \u0026#39;name\u0026#39; of non-numeric type string\u0026#34; } })    如果被$inc或$mul更新的字段不存在。。。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  \u0026gt; db.accounts.update( { name: \u0026#34;david\u0026#34; }, { $inc: { notYetExist: 10 } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) \u0026gt; db.accounts.find({ name: \u0026#34;david\u0026#34; }) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8ff\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34;, \u0026#34;balance\u0026#34; : 99.75, \u0026#34;notYetExist\u0026#34; : 10 } \u0026gt; db.accounts.update( { name: \u0026#34;david\u0026#34; }, { $mul: { notYetExistEither: 20 } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) \u0026gt; db.accounts.find({ name: \u0026#34;david\u0026#34; }) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8ff\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34;, \u0026#34;balance\u0026#34; : 99.75, \u0026#34;notYetExist\u0026#34; : 10, \u0026#34;notYetExistEither\u0026#34; : 0 }   $min 和 $max 操作符 比较之后更新字段值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  语法: { $min: { \u0026lt;field1\u0026gt;: \u0026lt;value1\u0026gt;, ... } } { $max: { \u0026lt;field1\u0026gt;: \u0026lt;value1\u0026gt;, ... } } # 查看 karen 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;karen\u0026#34; }, { name: 1, info: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;info\u0026#34; : { \u0026#34;dateOpened\u0026#34; : ISODate(\u0026#34;2017-01-01T16:00:00Z\u0026#34;), \u0026#34;balance\u0026#34; : 2500 } } # 更新 karen 的账户余额 # 比较 info.balance 字段原本的字段值与5000的大小，把这两者中较小的保留，作为 info.balance 字段的值 \u0026gt; db.accounts.update( { name: \u0026#34;karen\u0026#34; }, { $min: { \u0026#34;info.balance\u0026#34;: 5000 } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 0 }) # 更新 karen 的账户余额 # 比较 info.balance 字段原本的字段值与5000的大小，把这两者中较大的保留，作为 info.balance 字段的值 \u0026gt; db.accounts.update( { name: \u0026#34;karen\u0026#34; }, { $max: { \u0026#34;info.balance\u0026#34;: 5000 } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 karen 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;karen\u0026#34; }, { name: 1, info: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;info\u0026#34; : { \u0026#34;dateOpened\u0026#34; : ISODate(\u0026#34;2017-01-01T16:00:00Z\u0026#34;), \u0026#34;balance\u0026#34; : 5000 } } # 更新 karen 的开户时间 \u0026gt; db.accounts.update( { name: \u0026#34;karen\u0026#34; }, { $min: { \u0026#34;info.dateOpened\u0026#34;: new Date(\u0026#34;2013-10-01T16:00:00Z\u0026#34;) } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 karen 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;karen\u0026#34; }, { name: 1, info: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;info\u0026#34; : { \u0026#34;dateOpened\u0026#34; : ISODate(\u0026#34;2013-10-01T16:00:00Z\u0026#34;), \u0026#34;balance\u0026#34; : 5000 } }    注意: 如果被更新的字段不存在。。。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  \u0026gt; db.accounts.update( { name: \u0026#34;karen\u0026#34; }, { $min: { notYetExist: 10 } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 kaven 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;karen\u0026#34; }, { name: 1, info: 1, notYetExist: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;info\u0026#34; : { \u0026#34;dateOpened\u0026#34; : ISODate(\u0026#34;2013-10-01T16:00:00Z\u0026#34;), \u0026#34;balance\u0026#34; : 5000 }, \u0026#34;notYetExist\u0026#34; : 10 }    如果被更新的字段不存在，$min和$max命令会创建字段，并且将字段值设置为命令中的更新值如果被更新的字段类型和更新值类型不一致。。。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  \u0026gt; db.accounts.update( { name: \u0026#34;karen\u0026#34; }, { $min: { \u0026#34;info.balance\u0026#34;: null } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 karen 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;karen\u0026#34; }, { name: 1, info: 1, notYetExist: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;info\u0026#34; : { \u0026#34;dateOpened\u0026#34; : ISODate(\u0026#34;2013-10-01T16:00:00Z\u0026#34;), \u0026#34;balance\u0026#34; : null }, \u0026#34;notYetExist\u0026#34; : 10 }    如果被更新的字段类型和更新值类型不一致，$min和$max命令会按照BSON数据类型排序规则进行比较 1 2 3 4 5 6 7 8 9 10 11 12 13  (最小) Null Numbers (ints, longs, doubles, decimals) Symbol, String Object Array BinData ObjectId Boolean Date Timestamp Regular Expression (最大)   数组更新操作符 1 2 3 4 5  $addToSet 向数组中增添元素 $pop 从数组中移除元素 $pull 从数组中有选择性地移除元素 $pullAll 从数组中有选择性地移除元素 $push 向数组中增添元素   $addToSet 操作符 向数组字段中添加元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  语法: { $addToSet: { \u0026lt;field1\u0026gt;: \u0026lt;value1\u0026gt;, ... } } # 查看 karen 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;karen\u0026#34; }, { name: 1, contact: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;contact\u0026#34; : [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ], \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34;, { \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34;, \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34; } ] } # 向 karen 的账户文档中添加联系方式 \u0026gt; db.accounts.update( { name: \u0026#34;karen\u0026#34; }, { $addToSet: { contact: \u0026#34;China\u0026#34; } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 0 })    注意: 如果要插入的值已经存在数组字段中，则$addToSet不会再添加重复值注意一下，使用$addToSet插入数组和文档时，插入值中的字段顺序也和已有值重复的时候，才被算作重复值被忽略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127  # 向 karen 的账户文档中添加新的联系方式 \u0026gt; db.accounts.update( { name: \u0026#34;karen\u0026#34; }, { $addToSet: { contact: { \u0026#34;secondaryEmail\u0026#34;: \u0026#34;yyy@gmail.com\u0026#34;, \u0026#34;primaryEmail\u0026#34;: \u0026#34;xxx@gmail.com\u0026#34; } } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 karen 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;karen\u0026#34; }, { name: 1, contact: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;contact\u0026#34; : [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ], \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34;, { \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34;, \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34; }, { \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34;, \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34; } ] } ## 向数组字段中添加多个值 # 向 karen 的账户文档中添加多个联系方式 \u0026gt; db.accounts.update( { name: \u0026#34;karen\u0026#34; }, { $addToSet: { contact: [ \u0026#34;contact1\u0026#34;, \u0026#34;contact2\u0026#34; ] } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 karen 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;karen\u0026#34; }, { name: 1, contact: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;contact\u0026#34; : [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ], \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34;, { \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34;, \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34; }, { \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34;, \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34; }, [ \u0026#34;contact1\u0026#34;, \u0026#34;contact2\u0026#34; ] ] } #由此可见，默认情况下，$addToSet 会将数组插入被更新的数组字段中，成为内嵌数组 #如果想要将多个元素直接添加到数组字段中，则需要使用 $each 操作符 # 向 karen 的账户文档中添加多个联系方式 \u0026gt; db.accounts.update( { name: \u0026#34;karen\u0026#34; }, { $addToSet: { contact: { $each: [ \u0026#34;contact1\u0026#34;, \u0026#34;contact2\u0026#34; ] } } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 karen 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;karen\u0026#34; }, { name: 1, contact: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;contact\u0026#34; : [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ], \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34;, { \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34;, \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34; }, { \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34;, \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34; }, [ \u0026#34;contact1\u0026#34;, \u0026#34;contact2\u0026#34; ], \u0026#34;contact1\u0026#34;, \u0026#34;contact2\u0026#34; ] }   $pop 操作符 从数组字段中删除元素(只能删除数组中第一个或者最后一个元素)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121  语法: { $pop: { \u0026lt;field\u0026gt;: \u0026lt;-1 | 1\u0026gt;, ... } } # 从 karen 的账户文档中删除最后一个联系方式 \u0026gt; db.accounts.update( { name: \u0026#34;karen\u0026#34; }, { $pop: { contact: 1 } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 karen 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;karen\u0026#34; }, { name: 1, contact: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;contact\u0026#34; : [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ], \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34;, { \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34;, \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34; }, { \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34;, \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34; }, [ \u0026#34;contact1\u0026#34;, \u0026#34;contact2\u0026#34; ], \u0026#34;contact1\u0026#34; ] } # 从 karen 的账户文档中删除第一个联系方式 \u0026gt; db.accounts.update( { name: \u0026#34;karen\u0026#34; }, { $pop: { \u0026#34;contact.5\u0026#34;: -1 } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 karen 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;karen\u0026#34; }, { name: 1, contact: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;contact\u0026#34; : [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ], \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34;, { \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34;, \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34; }, { \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34;, \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34; }, [ \u0026#34;contact2\u0026#34; ], \u0026#34;contact1\u0026#34; ] } # 继续从 karen 的账户文档中删除联系方式 \u0026gt; db.accounts.update( { name: \u0026#34;karen\u0026#34; }, { $pop: { \u0026#34;contact.5\u0026#34;: -1 } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 karen 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;karen\u0026#34; }, { name: 1, contact: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;contact\u0026#34; : [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ], \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34;, { \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34;, \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34; }, { \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34;, \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34; }, [ ], \u0026#34;contact1\u0026#34; ] }    注意: 删除掉数组中最后一个元素后，会留下空数组$pop操作符只能应用在数组字段上 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026gt; db.accounts.update( { name: \u0026#34;karen\u0026#34; }, { $pop: { \u0026#34;contact.1\u0026#34;: -1 } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 0, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 0, \u0026#34;writeError\u0026#34; : { \u0026#34;code\u0026#34; : 14, \u0026#34;errmsg\u0026#34; : \u0026#34;Path \u0026#39;contact.1\u0026#39; contains an element of non-array type \u0026#39;string\u0026#39;\u0026#34; } })   $pull 操作符 从数组字段中删除特定元素(灵活性比$pop强)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130  语法: { $pull: { \u0026lt;field1\u0026gt;: \u0026lt;value | condition\u0026gt;, ... } } # 为了演示方便，首先将 karen 的账户文档复制成为一篇新文档，并且把新文档的用户姓名设置为 lawrence \u0026gt; db.accounts.find( { name: \u0026#34;karen\u0026#34; }, { _id: 0 } ).forEach(doc =\u0026gt; { var newDoc = doc; newDoc.name = \u0026#34;lawrence\u0026#34;; db.accounts.insert(newDoc); }) # 查看 lawrence 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;lawrence\u0026#34; } ).pretty() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce188c687c9a4c5934a9550\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;lawrence\u0026#34;, \u0026#34;contact\u0026#34; : [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ], \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34;, { \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34;, \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34; }, { \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34;, \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34; }, [ ], \u0026#34;contact1\u0026#34; ], \u0026#34;info\u0026#34; : { \u0026#34;dateOpened\u0026#34; : ISODate(\u0026#34;2013-10-01T16:00:00Z\u0026#34;), \u0026#34;balance\u0026#34; : null }, \u0026#34;branch\u0026#34; : \u0026#34;branch1\u0026#34;, \u0026#34;notYetExist\u0026#34; : 10 } # 从 karen 的联系方式中删除包含 \u0026#39;hi\u0026#39; 字母的元素 # 想一想，既然是针对数组元素的筛选条件，是否需要使用 $elemMatch 操作符呢？ \u0026gt; db.accounts.update( { name: \u0026#34;karen\u0026#34; }, { $pull: { contact: { $elemMatch: { $regex: /hi/ } } } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 0 }) # 事实上，既然 $pull 操作符本身是只能作用在数组元素上的，我们便不需要再额外使用 $elemMatch 操作符了 \u0026gt; db.accounts.update( { name: \u0026#34;karen\u0026#34; }, { $pull: { contact: { $regex: /hi/ } } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 karen 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;karen\u0026#34; }, { contact: 1, _id: 0 } ).pretty() { \u0026#34;contact\u0026#34; : [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ], \u0026#34;Beijing\u0026#34;, { \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34;, \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34; }, { \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34;, \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34; }, [ ], \u0026#34;contact1\u0026#34; ] } # 当然，如果有数组元素本身就是一个内嵌数组，我们也可以使用 $elemMatch 来对这些内嵌数组进行筛选 # 从 karen 的联系方式中删除电话号码 22222222 \u0026gt; db.accounts.update( { name: \u0026#34;karen\u0026#34; }, { $pull: { contact: { $elemMatch: { $eq: \u0026#34;22222222\u0026#34; }} } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 karen 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;karen\u0026#34; }, { contact: 1, _id: 0 } ).pretty() { \u0026#34;contact\u0026#34; : [ \u0026#34;Beijing\u0026#34;, { \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34;, \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34; }, { \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34;, \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34; }, [ ], \u0026#34;contact1\u0026#34; ] } # 这里需要说明一下，虽然 $elemMatch 匹配的是内嵌数组中的元素，但是 $pull 的删除操作是针对 contact 的顶级元素进行的，所以会把符合内嵌数组中的筛选条件的元素所在的顶级元素整个删除掉。 # 因此，33333333没有出现在查询结果中   $pullAll 操作符 从数组字段中删除特定元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186  { $pull: { \u0026lt;field1\u0026gt;: \u0026lt;value\u0026gt;, ... } } { $pullAll: { \u0026lt;field1\u0026gt;: [ \u0026lt;value1\u0026gt;, \u0026lt;value2\u0026gt;, ... ] } } { $pullAll: { \u0026lt;field1\u0026gt;: [ \u0026lt;value1\u0026gt;, \u0026lt;value2\u0026gt;, ... ] } } 相当于 { $pull: { \u0026lt;field1\u0026gt;: { $in: [ \u0026lt;value1\u0026gt;, \u0026lt;value2\u0026gt;, ... ] } } } ## 如果要删除的元素是一个内嵌数组，则数组元素的值和排列顺序都必须和被删除的数组完全一样 # 查看 lawrence 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;lawrence\u0026#34; }, { name: 1, contact: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;lawrence\u0026#34;, \u0026#34;contact\u0026#34; : [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ], \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34;, { \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34;, \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34; }, { \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34;, \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34; }, [ ], \u0026#34;contact1\u0026#34; ] } # 删除第一个联系方式 \u0026gt; db.accounts.update( { name: \u0026#34;lawrence\u0026#34; }, { $pullAll: { contact: [ [\u0026#34;33333333\u0026#34;, \u0026#34;22222222\u0026#34;] ] } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 0 }) # 因为排列顺序不一样，所以没有被删除 ## 如果要删除的元素是一个内嵌文档 $pullAll 命令只会删除字段和字段排列顺序都完全匹配的文档元素 # 查看 lawrence 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;lawrence\u0026#34; }, { name: 1, contact: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;lawrence\u0026#34;, \u0026#34;contact\u0026#34; : [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ], \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34;, { \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34;, \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34; }, { \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34;, \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34; }, [ ], \u0026#34;contact1\u0026#34; ] } \u0026gt; db.accounts.update( { name: \u0026#34;lawrence\u0026#34; }, { $pullAll: { contact: [ {\u0026#34;primaryEmail\u0026#34;:\u0026#34;xxx@gmail.com\u0026#34;} ] } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 0 }) # 因为提供给 $pullAll 的文档和源文档并没有完全匹配，所以没有删除 \u0026gt; db.accounts.update( { name: \u0026#34;lawrence\u0026#34; }, { $pullAll: { contact: [ { \u0026#34;secondaryEmail\u0026#34;: \u0026#34;yyy@gmail.com\u0026#34;, \u0026#34;primaryEmail\u0026#34;: \u0026#34;xxx@gmail.com\u0026#34; }, ] } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 只会删除第二个内嵌文档 # 查看 lawrence 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;lawrence\u0026#34; }, { name: 1, contact: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;lawrence\u0026#34;, \u0026#34;contact\u0026#34; : [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ], \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34;, { \u0026#34;primaryEmail\u0026#34; : \u0026#34;xxx@gmail.com\u0026#34;, \u0026#34;secondaryEmail\u0026#34; : \u0026#34;yyy@gmail.com\u0026#34; }, [ ], \u0026#34;contact1\u0026#34; ] } # 但是，$pull 命令会删除包含指定的文档字段和字段值的文档元素，字段排列顺序不需要完全匹配。 # 这一点和 $pullAll 不太一样 \u0026gt; db.accounts.update( { name: \u0026#34;lawrence\u0026#34; }, { $pull: { contact: { \u0026#34;primaryEmail\u0026#34;: \u0026#34;xxx@gmail.com\u0026#34; } } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # $pull 在删除内嵌文档的时候，允许部分匹配，他的模糊程度更高 # 查看 lawrence 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;lawrence\u0026#34; }, { name: 1, contact: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;lawrence\u0026#34;, \u0026#34;contact\u0026#34; : [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ], \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34;, [ ], \u0026#34;contact1\u0026#34; ] } # 将刚才删除的文档元素再添加到 contact 数组中去 \u0026gt; db.accounts.update( { name: \u0026#34;lawrence\u0026#34; }, { $addToSet: { contact: { \u0026#34;primaryEmail\u0026#34;: \u0026#34;xxx@gmail.com\u0026#34;, \u0026#34;secondaryEmail\u0026#34;: \u0026#34;yyy@gmail.com\u0026#34; } } } ) \u0026gt; db.accounts.update( { name: \u0026#34;lawrence\u0026#34; }, { $pull: { contact: { \u0026#34;secondaryEmail\u0026#34;: \u0026#34;yyy@gmail.com\u0026#34;, \u0026#34;primaryEmail\u0026#34;: \u0026#34;xxx@gmail.com\u0026#34; } } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 可以看到，$pull 在删除内嵌文档时，对字段的排列顺序没有要求   $push 操作符 向数组字段中添加元素\n$push和$addToSet命令相似，但是$push命令的功能更强大\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326  语法: { $push: { \u0026lt;field1\u0026gt;: \u0026lt;value1\u0026gt;, ... } } # 和 $addToSet 命令一样，如果 $push 命令中指定的数组字段不存在，则这个字段会被添加到原文档中 \u0026gt; db.accounts.update( { name: \u0026#34;lawrence\u0026#34; }, { $push: { newArray: \u0026#34;new element\u0026#34; } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 lawrence 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;lawrence\u0026#34; }, { name: 1, newArray: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;lawrence\u0026#34;, \u0026#34;newArray\u0026#34; : [ \u0026#34;new element\u0026#34; ] } ## 和 $addToSet 相似，$push 操作符也可以和 $each 搭配使用 \u0026gt; db.accounts.update( { name: \u0026#34;lawrence\u0026#34; }, { $push: { newArray: { $each: [ 2, 3, 4 ] } } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 lawrence 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;lawrence\u0026#34; }, { name: 1, newArray: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;lawrence\u0026#34;, \u0026#34;newArray\u0026#34; : [ \u0026#34;new element\u0026#34;, 2, 3, 4 ] } ## $push 和 $each 操作符还可以和更多的操作符搭配使用，实现比 $addToSet 更复杂的操作 ## 使用 $position 操作符将元素插入到数组的指定位置 \u0026gt; db.accounts.update( { name: \u0026#34;lawrence\u0026#34; }, { $push: { newArray: { $each: [ \u0026#34;pos1\u0026#34;, \u0026#34;pos2\u0026#34; ], $position: 0 } } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 lawrence 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;lawrence\u0026#34; }, { name: 1, newArray: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;lawrence\u0026#34;, \u0026#34;newArray\u0026#34; : [ \u0026#34;pos1\u0026#34;, \u0026#34;pos2\u0026#34;, \u0026#34;new element\u0026#34;, 2, 3, 4 ] } \u0026gt; db.accounts.update( { name: \u0026#34;lawrence\u0026#34; }, { $push: { newArray: { $each: [ \u0026#34;pos3\u0026#34;, \u0026#34;pos4\u0026#34; ], $position: -1 #插入到最后一个元素的前面 } } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 lawrence 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;lawrence\u0026#34; }, { name: 1, newArray: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;lawrence\u0026#34;, \u0026#34;newArray\u0026#34; : [ \u0026#34;pos1\u0026#34;, \u0026#34;pos2\u0026#34;, \u0026#34;new element\u0026#34;, 2, 3, \u0026#34;pos3\u0026#34;, \u0026#34;pos4\u0026#34;, 4 ] } ## 使用 $sort 对数组进行排序 \u0026gt; db.accounts.update( { name: \u0026#34;lawrence\u0026#34; }, { $push: { newArray: { $each: [ \u0026#34;sort1\u0026#34; ], $sort: 1 # 1升序 -1降序 } } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 lawrence 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;lawrence\u0026#34; }, { name: 1, newArray: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;lawrence\u0026#34;, \u0026#34;newArray\u0026#34; : [ 2, 3, 4, \u0026#34;new element\u0026#34;, \u0026#34;pos1\u0026#34;, \u0026#34;pos2\u0026#34;, \u0026#34;pos3\u0026#34;, \u0026#34;pos4\u0026#34;, \u0026#34;sort1\u0026#34; ] } # 如果插入的元素是一个内嵌文档，也可以根据内嵌文档的字段值进行排序 \u0026gt; db.accounts.update( { name: \u0026#34;lawrence\u0026#34; }, { $push: { newArray: { $each: [ { key: \u0026#34;sort\u0026#34;, value: 100 }, { key: \u0026#34;sort\u0026#34;, value: 200 } ], $sort: { value: -1 } # 1升序 -1降序 } } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 lawrence 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;lawrence\u0026#34; }, { name: 1, newArray: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;lawrence\u0026#34;, \u0026#34;newArray\u0026#34; : [ { \u0026#34;key\u0026#34; : \u0026#34;sort\u0026#34;, \u0026#34;value\u0026#34; : 200 }, { \u0026#34;key\u0026#34; : \u0026#34;sort\u0026#34;, \u0026#34;value\u0026#34; : 100 }, 2, 3, 4, \u0026#34;new element\u0026#34;, \u0026#34;pos1\u0026#34;, \u0026#34;pos2\u0026#34;, \u0026#34;pos3\u0026#34;, \u0026#34;pos4\u0026#34;, \u0026#34;sort1\u0026#34; ] } # 如果不想插入元素，只想对文档中的数组字段进行排序。。。 \u0026gt; db.accounts.update( { name: \u0026#34;lawrence\u0026#34; }, { $push: { newArray: { $each: [ ], $sort: -1 } } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 lawrence 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;lawrence\u0026#34; }, { name: 1, newArray: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;lawrence\u0026#34;, \u0026#34;newArray\u0026#34; : [ { \u0026#34;key\u0026#34; : \u0026#34;sort\u0026#34;, \u0026#34;value\u0026#34; : 200 }, { \u0026#34;key\u0026#34; : \u0026#34;sort\u0026#34;, \u0026#34;value\u0026#34; : 100 }, \u0026#34;sort1\u0026#34;, \u0026#34;pos4\u0026#34;, \u0026#34;pos3\u0026#34;, \u0026#34;pos2\u0026#34;, \u0026#34;pos1\u0026#34;, \u0026#34;new element\u0026#34;, 4, 3, 2 ] } ## 使用 $slice 来截取数组的一部分 \u0026gt; db.accounts.update( { name: \u0026#34;lawrence\u0026#34; }, { $push: { newArray: { $each: [ \u0026#34;slice1\u0026#34; ], $slice: -8 #只保留最后8个元素，其他的都被删除掉 } } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 lawrence 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;lawrence\u0026#34; }, { name: 1, newArray: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;lawrence\u0026#34;, \u0026#34;newArray\u0026#34; : [ \u0026#34;pos3\u0026#34;, \u0026#34;pos2\u0026#34;, \u0026#34;pos1\u0026#34;, \u0026#34;new element\u0026#34;, 4, 3, 2, \u0026#34;slice1\u0026#34; ] } # 如果不想插入元素，只想截取文档中的数组字段。。。 \u0026gt; db.accounts.update( { name: \u0026#34;lawrence\u0026#34; }, { $push: { newArray: { $each: [ ], $slice: 6 } } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 lawrence 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;lawrence\u0026#34; }, { name: 1, newArray: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;lawrence\u0026#34;, \u0026#34;newArray\u0026#34; : [ \u0026#34;pos3\u0026#34;, \u0026#34;pos2\u0026#34;, \u0026#34;pos1\u0026#34;, \u0026#34;new element\u0026#34;, 4, 3 ] } ## $position, $sort, $slice 可以一起使用 # 这三个操作符的执行顺序是: # $position -\u0026gt; $sort -\u0026gt; $slice # 写在命令中的操作符顺序并不重要，并不会影响命令的执行顺序 \u0026gt; db.accounts.update( { name: \u0026#34;lawrence\u0026#34; }, { $push: { newArray: { $each: [ \u0026#34;push1\u0026#34;, \u0026#34;push2\u0026#34; ], $position: 2, $sort: -1, $slice: 5 } } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 lawrence 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;lawrence\u0026#34; }, { name: 1, newArray: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;lawrence\u0026#34;, \u0026#34;newArray\u0026#34; : [ \u0026#34;push2\u0026#34;, \u0026#34;push1\u0026#34;, \u0026#34;pos3\u0026#34;, \u0026#34;pos2\u0026#34;, \u0026#34;pos1\u0026#34; ] }   $占位操作符 更新数组中的特定元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  语法: db.collection.update( { \u0026lt;array\u0026gt;: \u0026lt;query selector\u0026gt; }, { \u0026lt;update operator\u0026gt;: { \u0026#34;\u0026lt;array\u0026gt;.$\u0026#34;: value } } ) $ 是数组中第一个符合筛选条件的数组元素的占位符 搭配更新操作符使用，可以对满足筛选条件的数组元素进行更新 # 查看 lawrence 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;lawrence\u0026#34; }, { name: 1, newArray: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;lawrence\u0026#34;, \u0026#34;newArray\u0026#34; : [ \u0026#34;push2\u0026#34;, \u0026#34;push1\u0026#34;, \u0026#34;pos3\u0026#34;, \u0026#34;pos2\u0026#34;, \u0026#34;pos1\u0026#34; ] } \u0026gt; db.accounts.update( { name: \u0026#34;lawrence\u0026#34;, newArray: \u0026#34;pos2\u0026#34; }, { $set: { \u0026#34;newArray.$\u0026#34;: \u0026#34;updated\u0026#34; } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 lawrence 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;lawrence\u0026#34; }, { name: 1, newArray: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;lawrence\u0026#34;, \u0026#34;newArray\u0026#34; : [ \u0026#34;push2\u0026#34;, \u0026#34;push1\u0026#34;, \u0026#34;pos3\u0026#34;, \u0026#34;updated\u0026#34;, \u0026#34;pos1\u0026#34; ] }   更新数组中的所有元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  语法: db.collection.update( { \u0026lt;query\u0026gt; }, { \u0026lt;update operator\u0026gt;: { \u0026#34;\u0026lt;array\u0026gt;.$[]\u0026#34;: value } } ) $[] 指代数组字段中的所有元素 搭配更新操作符使用，可以对数组中所有的元素进行更新 # 查看 lawrence 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;lawrence\u0026#34; }, { name: 1, contact: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;lawrence\u0026#34;, \u0026#34;contact\u0026#34; : [ [ \u0026#34;22222222\u0026#34;, \u0026#34;33333333\u0026#34; ], \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34;, [ ], \u0026#34;contact1\u0026#34; ] } \u0026gt; db.accounts.update( { name: \u0026#34;lawrence\u0026#34; }, { $set: { \u0026#34;contact.0.$[]\u0026#34;: \u0026#34;88888888\u0026#34; } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看 lawrence 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;lawrence\u0026#34; }, { name: 1, contact: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;lawrence\u0026#34;, \u0026#34;contact\u0026#34; : [ [ \u0026#34;88888888\u0026#34;, \u0026#34;88888888\u0026#34; ], \u0026#34;Beijing\u0026#34;, \u0026#34;China\u0026#34;, [ ], \u0026#34;contact1\u0026#34; ] }   update options db.\u0026lt;collection\u0026gt;.update(\u0026lt;query\u0026gt;, \u0026lt;update\u0026gt;, \u0026lt;options\u0026gt;)\n\u0026lt;options\u0026gt;参数提供了update命令的更多选项\nmulti 更新多个文档 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  语法: { multi: \u0026lt;boolean\u0026gt; } 在默认情况下，即使筛选条件对应了多篇文档，update命令仍然只会更新一篇文档 \u0026gt; db.accounts.update( {}, { $set: { currency: \u0026#34;USD\u0026#34; } } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看银行账户文档 \u0026gt; db.accounts.find( {}, { name: 1, currency: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;currency\u0026#34; : \u0026#34;USD\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;bill\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;charlie\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;fred\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34; } { } { \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34; } # 使用 multi 选项来更新多个符合筛选条件的文档 \u0026gt; db.accounts.update( {}, { $set: { currency: \u0026#34;USD\u0026#34; } }, { multi: true } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 24, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 23 }) # 查看银行账户文档 \u0026gt; db.accounts.find( {}, { name: 1, currency: 1, _id: 0 } ).pretty() { \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;currency\u0026#34; : \u0026#34;USD\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;bill\u0026#34;, \u0026#34;currency\u0026#34; : \u0026#34;USD\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;charlie\u0026#34;, \u0026#34;currency\u0026#34; : \u0026#34;USD\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34;, \u0026#34;currency\u0026#34; : \u0026#34;USD\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;fred\u0026#34;, \u0026#34;currency\u0026#34; : \u0026#34;USD\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34;, \u0026#34;currency\u0026#34; : \u0026#34;USD\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;currency\u0026#34; : \u0026#34;USD\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34;, \u0026#34;currency\u0026#34; : \u0026#34;USD\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;currency\u0026#34; : \u0026#34;USD\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;currency\u0026#34; : \u0026#34;USD\u0026#34; } { \u0026#34;currency\u0026#34; : \u0026#34;USD\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34;, \u0026#34;currency\u0026#34; : \u0026#34;USD\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;currency\u0026#34; : \u0026#34;USD\u0026#34; }    注意: MongoDB只能保证单个文档操作的原子性，不能保证多个文档操作的原子性更新多个文档的操作虽然在单一线程中执行，但是线程在执行过程中可能会被挂起，以便其他线程也有机会对数据进行操作如果需要保证多个文档操作时的原子性，就需要使用MongoDB 4.0版本中引入的事物功能进行操作 upsert 更新或创建文档 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  语法: { upsert: \u0026lt;boolean\u0026gt; } 在默认情况下，如果 update 命令中的筛选条件没有匹配任何文档，则不会进行任何操作 将 upsert 选项设置为 true, 如果 update 命令中的筛选条件没有匹配任何文档，则会创建新文档 # 查看 maggie 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;maggie\u0026#34; }, { name: 1, balance: 1, _id: 0 } ) 无输出，说明没有这个用户 \u0026gt; db.accounts.update( { name: \u0026#34;maggie\u0026#34; }, { $set: { balance: 700 } }, { upsert: true } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 0, \u0026#34;nUpserted\u0026#34; : 1, \u0026#34;nModified\u0026#34; : 0, \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce23eaf65fdd3b3b65b3810\u0026#34;) }) # 查看 maggie 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;maggie\u0026#34; }, { name: 1, balance: 1, _id: 0 } ) { \u0026#34;name\u0026#34; : \u0026#34;maggie\u0026#34;, \u0026#34;balance\u0026#34; : 700 } 如果无法从筛选条件中推断出确定的字段值，新创建的文档将不会包含筛选条件涉及的字段 \u0026gt; db.accounts.update( { balance: { $gt: 20000 } }, { $set: { name: \u0026#34;nick\u0026#34; } }, { upsert: true } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 0, \u0026#34;nUpserted\u0026#34; : 1, \u0026#34;nModified\u0026#34; : 0, \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce2403b65fdd3b3b65b3869\u0026#34;) }) # 查看 nick 的银行账户文档 \u0026gt; db.accounts.find( { name: \u0026#34;nick\u0026#34; }, { name: 1, balance: 1, _id: 0 } ) { \u0026#34;name\u0026#34; : \u0026#34;nick\u0026#34; } # 👆这里没有包含 balance 字段   save 这个命令也可以用来更新文档\n1 2  语法: db.\u0026lt;collection\u0026gt;.save(\u0026lt;document\u0026gt;)   如果document文档中包含了_id字段，save()命令将会调用db.collection.update()命令(upsert选项被打开)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  # 查看银行账户文档 \u0026gt; db.accounts.find( {}, { name: 1, _id: 1 } ) { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34; } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00c9672e77e7cb392a8fd\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;bill\u0026#34; } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8fe\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;charlie\u0026#34; } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00d5972e77e7cb392a8ff\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34; } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce00f5272e77e7cb392a901\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;fred\u0026#34; } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce011fd72e77e7cb392a902\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;george\u0026#34; } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce0f15c72e77e7cb392a90c\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34; } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;001\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34; } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;savings\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;002\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34; } { \u0026#34;_id\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;alipay\u0026#34;, \u0026#34;accountId\u0026#34; : \u0026#34;003\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34; } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1107d72e77e7cb392a90d\u0026#34;) } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1107d72e77e7cb392a90e\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34; } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5ce1225972e77e7cb392a90f\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34; } # _id已存在，更新已有文档 \u0026gt; db.accounts.save( { _id: \u0026#34;account1\u0026#34;, name: \u0026#34;alice\u0026#34;, balance: 100 } ) 相当于执行 \u0026gt; db.accounts.update( { _id: \u0026#34;account1\u0026#34; }, { $set: { name: \u0026#34;alice\u0026#34;, balance: 100 } }, { upsert: true } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) # 查看银行账户文档 \u0026gt; db.accounts.find({ name: \u0026#34;alice\u0026#34; }) { \u0026#34;_id\u0026#34; : \u0026#34;account1\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;balance\u0026#34; : 100 } # _id不存在，创建新文档 \u0026gt; db.accounts.save( { _id: \u0026#34;account2\u0026#34;, name: \u0026#34;oliver\u0026#34;, balance: 100 } ) 相当于执行 \u0026gt; db.accounts.update( { _id: \u0026#34;account2\u0026#34; }, { $set: { name: \u0026#34;oliver\u0026#34;, balance: 100 } }, { upsert: true } ) WriteResult({ \u0026#34;nMatched\u0026#34; : 0, \u0026#34;nUpserted\u0026#34; : 1, \u0026#34;nModified\u0026#34; : 0, \u0026#34;_id\u0026#34; : \u0026#34;account2\u0026#34; }) # 查看银行账户文档 \u0026gt; db.accounts.find({ name: \u0026#34;oliver\u0026#34; }) { \u0026#34;_id\u0026#34; : \u0026#34;account2\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;oliver\u0026#34;, \u0026#34;balance\u0026#34; : 100 }   删除文档 ¶ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85  语法: db.\u0026lt;collection\u0026gt;.remove(\u0026lt;query\u0026gt;, \u0026lt;options\u0026gt;) # \u0026lt;query\u0026gt;文档定义了删除操作时筛选文档的条件 # 这里的\u0026lt;query\u0026gt;文档与 db.collection.find() 中的 \u0026lt;query\u0026gt; 文档是相同的 # \u0026lt;options\u0026gt;文档声明了一些删除操作的选项 # 查看银行账户文档 \u0026gt; db.accounts.find( {}, { name: 1, balance: 1, _id: 0 } ).sort({ balance: 1 }) { } { \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34; } { } { \u0026#34;name\u0026#34; : \u0026#34;lawrence\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;nick\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;fred\u0026#34;, \u0026#34;balance\u0026#34; : 20 } { \u0026#34;name\u0026#34; : \u0026#34;bill\u0026#34;, \u0026#34;balance\u0026#34; : 80 } { \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34;, \u0026#34;balance\u0026#34; : 99.75 } { \u0026#34;name\u0026#34; : \u0026#34;alice\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;name\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;name\u0026#34; : \u0026#34;oliver\u0026#34;, \u0026#34;balance\u0026#34; : 100 } { \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 200 } # 删除余额为100的银行账户文档 \u0026gt; db.accounts.remove({ balance: 100 }) WriteResult({ \u0026#34;nRemoved\u0026#34; : 4 }) # 查看银行账户文档 \u0026gt; db.accounts.find( {}, { name: 1, balance: 1, _id: 0 } ).sort({ balance: 1 }) { } { \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34; } { } { \u0026#34;name\u0026#34; : \u0026#34;lawrence\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;nick\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;fred\u0026#34;, \u0026#34;balance\u0026#34; : 20 } { \u0026#34;name\u0026#34; : \u0026#34;bill\u0026#34;, \u0026#34;balance\u0026#34; : 80 } { \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34;, \u0026#34;balance\u0026#34; : 99.75 } { \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 200 } # 在默认情况下，remove 命令会删除所有符合筛选条件的文档 # 如果只想删除满足筛选条件的一篇文档，可以使用 justOne 选项 # 删除一篇余额小于100的银行账户文档 \u0026gt; db.accounts.remove( { balance: { $lt: 100 } }, { justOne: true } ) WriteResult({ \u0026#34;nRemoved\u0026#34; : 1 }) # 查看银行账户文档 \u0026gt; db.accounts.find( {}, { name: 1, balance: 1, _id: 0 } ).sort({ balance: 1 }) { } { \u0026#34;name\u0026#34; : \u0026#34;karen\u0026#34; } { } { \u0026#34;name\u0026#34; : \u0026#34;lawrence\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;nick\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;fred\u0026#34;, \u0026#34;balance\u0026#34; : 20 } { \u0026#34;name\u0026#34; : \u0026#34;david\u0026#34;, \u0026#34;balance\u0026#34; : 99.75 } { \u0026#34;name\u0026#34; : \u0026#34;john\u0026#34;, \u0026#34;balance\u0026#34; : 200 } { \u0026#34;name\u0026#34; : \u0026#34;champ\u0026#34;, \u0026#34;balance\u0026#34; : 200 } # 删除集合内的所有文档 \u0026gt; db.accounts.remove({}) WriteResult({ \u0026#34;nRemoved\u0026#34; : 22 }) # 查看银行账户文档 \u0026gt; db.accounts.find( {}, { name: 1, balance: 1, _id: 0 } ).sort({ balance: 1 }) 无输出   删除集合 ¶ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  语法: db.\u0026lt;collection\u0026gt;.drop( { writeConcern: \u0026lt;document\u0026gt; } ) 这里的 writeConcern 文档定义了本次集合删除操作的安全写级别 # 之前的 remove 命令可以删除集合内的所有文档，但是不会删除集合 \u0026gt; show collections accounts # drop 命令可以删除整个集合，包括集合中的所有文档，以及集合的索引 \u0026gt; db.accounts.drop() true \u0026gt; show collections 无输出 # 如果集合中的文档数量很多，使用 remove 命令删除所有文档的效率不高 # 这种情况下，更加有效率的方法，是使用 drop 命令删除整个集合，然后再创建空集合并创建索引   "},{"href":"https://blog.champ.design/posts/2019/05/mac-cheat-sheet/","title":"Mac 实用技巧","body":"微调音量 ¶ Shift + Option + 音量键 可以以 1/4 倍调整音量，实现更精细的控制音量\n删除键 ¶ 1 2 3 4 5  单按 delete 删除光标之前的一个字符（默认） 组合 `fn + delete`，删除光标之后的一个字符 组合`option + delete`，删除光标之前的一个单词(英文有效) 组合`fn + option + delete`，删除光标之后的一个单词 组合`command + delete`，删除文件   "},{"href":"https://blog.champ.design/posts/2019/05/koa-scaffold/","title":"Koa 项目脚手架","body":"由于 koa 框架非常精简，不捆绑任何中间件，因此，路由、日志等这些常见的功能都是由单独的模块提供。这里列举一些常用的中间件，可以作为脚手架使用。\nkoa-router ¶ 项目地址: https://github.com/ZijianHe/koa-router 1  npm install koa-router   koa-body ¶ 项目地址: https://github.com/dlau/koa-body 用于解析 post/put/... 请求时的 body，支持 json、urlenocded、multipart等格式。\n1  npm install koa-body   @koa/cors ¶ 项目地址: https://github.com/koajs/cors 官方提供的cors跨域解决方案\n1  npm install @koa/cors   koa-session ¶ 项目地址: https://github.com/koajs/session 1  npm install koa-session   koa-logger ¶ 项目地址: https://github.com/koajs/logger 1  npm install koa-logger   koa-compress ¶ 项目地址: https://github.com/koajs/compress 1  npm install koa-compress   koa-static ¶ 项目地址: https://github.com/koajs/static 1  npm install koa-static   koa-csrf ¶ 项目地址: https://github.com/koajs/csrf 1  npm install koa-csrf   koa-jwt ¶ 项目地址: https://github.com/koajs/jwt 用于验证jwt\n1  npm install koa-jwt    注意: 从koa-v2分支之后，koa-jwt不再提供sign,verify,decode等函数因此，需要通过下面的jsonwebtoken来生成jwt jsonwebtoken ¶ 项目地址: https://github.com/auth0/node-jsonwebtoken 用于生成jwt\n1  npm install jsonwebtoken   koa-helmet ¶ 项目地址: https://github.com/venables/koa-helmet 安全方面的配置\n1  npm install koa-static   mongoose ¶ 项目地址: https://github.com/Automattic/mongoose MongoDB 数据库的nodejs客户端\n1  npm install mongoose   "},{"href":"https://blog.champ.design/posts/2019/05/koa-learn-note/","title":"Koa 学习笔记","body":"nodemon工具的使用 ¶ 工具说明: 类似于前端开发，我希望node服务器运行起来之后，当我修改了我的代码之后，服务会自动重启，不需要我每次都手动重启服务。\n项目地址: https://github.com/remy/nodemon 1 2  $ node install -g nodemon #全局安装 $ nodemon app.js #用 nodemon 替代 node 来启动应用   关于Generator ¶ 在老的教程中，中间件的写法会有很多生成器函数的用法，比如:\n1 2 3 4 5  app.use(function* (next) { console.log(\u0026#34;1\u0026#34;); yield next; console.log(\u0026#34;2\u0026#34;); });   在koa的v2版中，写法发生了变化:\n1 2 3 4 5  app.use(async (ctx, next) =\u0026gt; { console.log(\u0026#34;1\u0026#34;); await next(); console.log(\u0026#34;2\u0026#34;); })    不知道这个是不是只是一个语法的问题，抽时间需要研究一下。 附上es6 generator的教程 MDN function*语法 阮一峰的文章 introduction to koa generator  关于 async/await 与 Promise ¶ async/await 是 Promise 的语法糖，向👇看: 下面这两个函数是等价的:\n1 2 3 4 5 6 7 8 9  async function foo() { return 42; } function foo() { return new Promise((resolve, reject) =\u0026gt; { resolve(42); }); }   在 async 函数里面抛的错误，会出现在 rejected promise 中:\n1 2 3 4 5 6 7 8 9  async function foo() { throw new Error(\u0026#39;oops!\u0026#39;); } function foo() { return new Promise((resolve, reject) =\u0026gt; { reject(new Error(\u0026#39;oops!\u0026#39;)); }); }   另外，在 async 函数中，我们可以使用 await 关键字去等待另一个 promised 函数返回，然后把结果赋给一个局部变量:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  async function foo() { const userId = 42; const user = await User.findById(userId); return user.name; } function foo() { const userId = 42; return User.findById(userId).then(user =\u0026gt; { return user.name; }); }   参考 ¶ tutorial spoint koajs/examples "},{"href":"https://blog.champ.design/posts/2019/05/linux-command/","title":"Linux常用命令","body":"清空文件内容 ¶ 1 2 3 4 5 6 7  $ \u0026gt; filename #这个命令执行完之后，不会自动退出，需要按Ctrl+D结束 $ : \u0026gt; filename #我最常用的，:是一个占位符，不产生任何输出 $ echo \u0026#39;\u0026#39; \u0026gt; filename $ echo /dev/null \u0026gt; filename $ echo \u0026gt; filename $ cat /dev/null \u0026gt; filename $ cp /dev/null filename    关于上面几个命令的解释： \u0026gt; filename的意思是，从标准输入中读取内容并写入到文件filename中，执行完该命令之后，需要立即执行Ctrl+D表示结束输入，因为此时并没有输入任何内容，所以文件就被清空了。 : \u0026gt; filename是上面的改进版，不需要手动执行Ctrl+D   按照时间删除文件 ¶ 有时候，我会不小心把整个目录下的所有文件上传到服务器上的一个错误的目录下，然后想删除刚上传的文件。但是登录到服务器之后，发现这个目录下不仅仅是刚上传的文件，还有之前就存在的一些文件。而我又不能把这个目录下的所有文件都删除掉，我只想删除刚刚上传的那些文件，也就是说，我只想删除刚刚修改的文件。截图如下:\n1 2  find . -mtime -10 #查找当前目录下，10天内修改过的所有文件 find . -mtime -10 -exec rm -Rf {} \\;   rsync 使用自定义 ssh key 进行发布 ¶ 1  rsync -Pav public/ ubuntu@tencent:/var/www/xkiller   "},{"href":"https://blog.champ.design/posts/2019/05/nodejs-learn-note/","title":"Nodejs之nextTick vs setImmediate","body":"关于 process.nextTick 和 setImmediate 执行时机的问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 加入两个nextTick()的回调函数 process.nextTick(function () { console.log(\u0026#39;nextTick延迟执行1\u0026#39;); }); process.nextTick(function () { console.log(\u0026#39;nextTick延迟执行2\u0026#39;); }); // 加入两个setImmediate()的回调函数 setImmediate(function () { console.log(\u0026#39;setImmediate延迟执行1\u0026#39;); // 进入下次循环  process.nextTick(function () { console.log(\u0026#39;强势插入\u0026#39;); }); }); setImmediate(function () { console.log(\u0026#39;setImmediate延迟执行2\u0026#39;); }); console.log(\u0026#39;正常执行\u0026#39;);   《nodejs深入浅出》的3.4章中的代码执行结果如下：\n正常执行 nextTick延迟执行1 nextTick延迟执行2 setImmediate延迟执行1 强势插入 setImmediate延迟执行2 参见 可能是因为node版本不同，我在本地的执行结果如下：\n正常执行 nextTick延迟执行1 nextTick延迟执行2 setImmediate延迟执行1 setImmediate延迟执行2 强势插入 1 2  $ node -v v10.15.0   nextTick vs setImmediate stack-overflow 官方文档说明 更多文章 "},{"href":"https://blog.champ.design/posts/2019/05/setup-your-own-git-server/","title":"搭建自己的git服务器","body":"环境: server: ubuntu 16.4\n第一步，安装git: sudo apt-get install git\n第二步，创建一个git用户，用来运行git服务： sudo adduser git\n第三步，创建证书登录： 收集所有需要登录的用户的公钥，导入到 /home/git/.ssh/authorized_keys 文件中，一行一个。\n第四步，初始化git裸仓库： cd /srv sudo git init \u0026ndash;bare blog.git sudo chown -R git:git blog.git\n第五步，禁用shell登录： 编辑 /etc/passwd 文件，如下：\ngit❌1001:1001:,,,:/home/git:/bin/bash git❌1001:1001:,,,:/home/git:/user/bin/git-shell 第六步，克隆远程仓库： git clone git@server:/srv/blog.git\n第七步，设置本地仓库的origin： 如果先有本地仓库，后有服务器的裸仓库，可以设置本地仓库的origin:\n"},{"href":"https://blog.champ.design/about/","title":"","body":"关于我 ¶ 你好，我是 champkeh，小名 champ，欢迎来到我的个人小站。\n我是一名 Web 开发者，曾从事过 .NET 后端开发的工作(2年)，目前主要工作内容为前端开发。 同时我也对golang语言很感兴趣。\n如果你有任何问题，都可以通过下面的方式联系到我。\n Y2hhbXBpb24uZ2VAZ21haWwuY29t (邮箱) / Github "},{"href":"https://blog.champ.design/search/index.json","title":"","body":""}]}